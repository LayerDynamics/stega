// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { bgGreen, bgRed, bold, gray, green, red, white } from "../fmt/colors.ts";
export const DiffType = {
  removed: "removed",
  common: "common",
  added: "added"
};
const REMOVED = 1;
const COMMON = 2;
const ADDED = 3;
function createCommon(A, B, reverse) {
  const common = [];
  if (A.length === 0 || B.length === 0) return [];
  for(let i = 0; i < Math.min(A.length, B.length); i += 1){
    const a = reverse ? A[A.length - i - 1] : A[i];
    const b = reverse ? B[B.length - i - 1] : B[i];
    if (a !== undefined && a === b) {
      common.push(a);
    } else {
      return common;
    }
  }
  return common;
}
function ensureDefined(item) {
  if (item === undefined) {
    throw Error("Unexpected missing FarthestPoint");
  }
  return item;
}
/**
 * Renders the differences between the actual and expected values
 * @param A Actual value
 * @param B Expected value
 */ export function diff(A, B) {
  const prefixCommon = createCommon(A, B);
  const suffixCommon = createCommon(A.slice(prefixCommon.length), B.slice(prefixCommon.length), true).reverse();
  A = suffixCommon.length ? A.slice(prefixCommon.length, -suffixCommon.length) : A.slice(prefixCommon.length);
  B = suffixCommon.length ? B.slice(prefixCommon.length, -suffixCommon.length) : B.slice(prefixCommon.length);
  const swapped = B.length > A.length;
  [A, B] = swapped ? [
    B,
    A
  ] : [
    A,
    B
  ];
  const M = A.length;
  const N = B.length;
  if (!M && !N && !suffixCommon.length && !prefixCommon.length) return [];
  if (!N) {
    return [
      ...prefixCommon.map((c)=>({
          type: DiffType.common,
          value: c
        })),
      ...A.map((a)=>({
          type: swapped ? DiffType.added : DiffType.removed,
          value: a
        })),
      ...suffixCommon.map((c)=>({
          type: DiffType.common,
          value: c
        }))
    ];
  }
  const offset = N;
  const delta = M - N;
  const size = M + N + 1;
  const fp = Array.from({
    length: size
  }, ()=>({
      y: -1,
      id: -1
    }));
  /**
   * INFO:
   * This buffer is used to save memory and improve performance.
   * The first half is used to save route and last half is used to save diff
   * type.
   * This is because, when I kept new uint8array area to save type,performance
   * worsened.
   */ const routes = new Uint32Array((M * N + size + 1) * 2);
  const diffTypesPtrOffset = routes.length / 2;
  let ptr = 0;
  let p = -1;
  function backTrace(A, B, current, swapped) {
    const M = A.length;
    const N = B.length;
    const result = [];
    let a = M - 1;
    let b = N - 1;
    let j = routes[current.id];
    let type = routes[current.id + diffTypesPtrOffset];
    while(true){
      if (!j && !type) break;
      const prev = j;
      if (type === REMOVED) {
        result.unshift({
          type: swapped ? DiffType.removed : DiffType.added,
          value: B[b]
        });
        b -= 1;
      } else if (type === ADDED) {
        result.unshift({
          type: swapped ? DiffType.added : DiffType.removed,
          value: A[a]
        });
        a -= 1;
      } else {
        result.unshift({
          type: DiffType.common,
          value: A[a]
        });
        a -= 1;
        b -= 1;
      }
      j = routes[prev];
      type = routes[prev + diffTypesPtrOffset];
    }
    return result;
  }
  function createFP(slide, down, k, M) {
    if (slide && slide.y === -1 && down && down.y === -1) {
      return {
        y: 0,
        id: 0
      };
    }
    const isAdding = down?.y === -1 || k === M || (slide?.y || 0) > (down?.y || 0) + 1;
    if (slide && isAdding) {
      const prev = slide.id;
      ptr++;
      routes[ptr] = prev;
      routes[ptr + diffTypesPtrOffset] = ADDED;
      return {
        y: slide.y,
        id: ptr
      };
    } else if (down && !isAdding) {
      const prev = down.id;
      ptr++;
      routes[ptr] = prev;
      routes[ptr + diffTypesPtrOffset] = REMOVED;
      return {
        y: down.y + 1,
        id: ptr
      };
    } else {
      throw new Error("Unexpected missing FarthestPoint");
    }
  }
  function snake(k, slide, down, _offset, A, B) {
    const M = A.length;
    const N = B.length;
    if (k < -N || M < k) return {
      y: -1,
      id: -1
    };
    const fp = createFP(slide, down, k, M);
    while(fp.y + k < M && fp.y < N && A[fp.y + k] === B[fp.y]){
      const prev = fp.id;
      ptr++;
      fp.id = ptr;
      fp.y += 1;
      routes[ptr] = prev;
      routes[ptr + diffTypesPtrOffset] = COMMON;
    }
    return fp;
  }
  let currentFP = ensureDefined(fp[delta + offset]);
  while(currentFP && currentFP.y < N){
    p = p + 1;
    for(let k = -p; k < delta; ++k){
      fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
    }
    for(let k = delta + p; k > delta; --k){
      fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
    }
    fp[delta + offset] = snake(delta, fp[delta - 1 + offset], fp[delta + 1 + offset], offset, A, B);
    currentFP = ensureDefined(fp[delta + offset]);
  }
  return [
    ...prefixCommon.map((c)=>({
        type: DiffType.common,
        value: c
      })),
    ...backTrace(A, B, currentFP, swapped),
    ...suffixCommon.map((c)=>({
        type: DiffType.common,
        value: c
      }))
  ];
}
/**
 * Renders the differences between the actual and expected strings
 * Partially inspired from https://github.com/kpdecker/jsdiff
 * @param A Actual string
 * @param B Expected string
 */ export function diffstr(A, B) {
  function unescape(string) {
    // unescape invisible characters.
    // ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#escape_sequences
    return string.replaceAll("\b", "\\b").replaceAll("\f", "\\f").replaceAll("\t", "\\t").replaceAll("\v", "\\v").replaceAll(/\r\n|\r|\n/g, (str)=>str === "\r" ? "\\r" : str === "\n" ? "\\n\n" : "\\r\\n\r\n");
  }
  function tokenize(string, { wordDiff = false } = {}) {
    if (wordDiff) {
      // Split string on whitespace symbols
      const tokens = string.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
      // Extended Latin character set
      const words = /^[a-zA-Z\u{C0}-\u{FF}\u{D8}-\u{F6}\u{F8}-\u{2C6}\u{2C8}-\u{2D7}\u{2DE}-\u{2FF}\u{1E00}-\u{1EFF}]+$/u;
      // Join boundary splits that we do not consider to be boundaries and merge empty strings surrounded by word chars
      for(let i = 0; i < tokens.length - 1; i++){
        const token = tokens[i];
        const tokenPlusTwo = tokens[i + 2];
        if (!tokens[i + 1] && token && tokenPlusTwo && words.test(token) && words.test(tokenPlusTwo)) {
          tokens[i] += tokenPlusTwo;
          tokens.splice(i + 1, 2);
          i--;
        }
      }
      return tokens.filter((token)=>token);
    } else {
      // Split string on new lines symbols
      const tokens = [];
      const lines = string.split(/(\n|\r\n)/);
      // Ignore final empty token when text ends with a newline
      if (!lines[lines.length - 1]) {
        lines.pop();
      }
      // Merge the content and line separators into single tokens
      for (const [i, line] of lines.entries()){
        if (i % 2) {
          tokens[tokens.length - 1] += line;
        } else {
          tokens.push(line);
        }
      }
      return tokens;
    }
  }
  // Create details by filtering relevant word-diff for current line
  // and merge "space-diff" if surrounded by word-diff for cleaner displays
  function createDetails(line, tokens) {
    return tokens.filter(({ type })=>type === line.type || type === DiffType.common).map((result, i, t)=>{
      const token = t[i - 1];
      if (result.type === DiffType.common && token && token.type === t[i + 1]?.type && /\s+/.test(result.value)) {
        return {
          ...result,
          type: token.type
        };
      }
      return result;
    });
  }
  // Compute multi-line diff
  const diffResult = diff(tokenize(`${unescape(A)}\n`), tokenize(`${unescape(B)}\n`));
  const added = [];
  const removed = [];
  for (const result of diffResult){
    if (result.type === DiffType.added) {
      added.push(result);
    }
    if (result.type === DiffType.removed) {
      removed.push(result);
    }
  }
  // Compute word-diff
  const hasMoreRemovedLines = added.length < removed.length;
  const aLines = hasMoreRemovedLines ? added : removed;
  const bLines = hasMoreRemovedLines ? removed : added;
  for (const a of aLines){
    let tokens = [];
    let b;
    // Search another diff line with at least one common token
    while(bLines.length){
      b = bLines.shift();
      const tokenized = [
        tokenize(a.value, {
          wordDiff: true
        }),
        tokenize(b?.value ?? "", {
          wordDiff: true
        })
      ];
      if (hasMoreRemovedLines) tokenized.reverse();
      tokens = diff(tokenized[0], tokenized[1]);
      if (tokens.some(({ type, value })=>type === DiffType.common && value.trim().length)) {
        break;
      }
    }
    // Register word-diff details
    a.details = createDetails(a, tokens);
    if (b) {
      b.details = createDetails(b, tokens);
    }
  }
  return diffResult;
}
/**
 * Colors the output of assertion diffs
 * @param diffType Difference type, either added or removed
 */ function createColor(diffType, { background = false } = {}) {
  // TODO(@littledivy): Remove this when we can detect
  // true color terminals.
  // https://github.com/denoland/deno_std/issues/2575
  background = false;
  switch(diffType){
    case DiffType.added:
      return (s)=>background ? bgGreen(white(s)) : green(bold(s));
    case DiffType.removed:
      return (s)=>background ? bgRed(white(s)) : red(bold(s));
    default:
      return white;
  }
}
/**
 * Prefixes `+` or `-` in diff output
 * @param diffType Difference type, either added or removed
 */ function createSign(diffType) {
  switch(diffType){
    case DiffType.added:
      return "+   ";
    case DiffType.removed:
      return "-   ";
    default:
      return "    ";
  }
}
export function buildMessage(diffResult, { stringDiff = false } = {}) {
  const messages = [];
  const diffMessages = [];
  messages.push("");
  messages.push("");
  messages.push(`    ${gray(bold("[Diff]"))} ${red(bold("Actual"))} / ${green(bold("Expected"))}`);
  messages.push("");
  messages.push("");
  diffResult.forEach((result)=>{
    const c = createColor(result.type);
    const line = result.details?.map((detail)=>detail.type !== DiffType.common ? createColor(detail.type, {
        background: true
      })(detail.value) : detail.value).join("") ?? result.value;
    diffMessages.push(c(`${createSign(result.type)}${line}`));
  });
  messages.push(...stringDiff ? [
    diffMessages.join("")
  ] : diffMessages);
  messages.push("");
  return messages;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vZGVuby5sYW5kL3N0ZEAwLjIyNC4wL2ludGVybmFsL2RpZmYudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTgtMjAyNCB0aGUgRGVubyBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBNSVQgbGljZW5zZS5cbi8vIFRoaXMgbW9kdWxlIGlzIGJyb3dzZXIgY29tcGF0aWJsZS5cblxuaW1wb3J0IHtcbiAgYmdHcmVlbixcbiAgYmdSZWQsXG4gIGJvbGQsXG4gIGdyYXksXG4gIGdyZWVuLFxuICByZWQsXG4gIHdoaXRlLFxufSBmcm9tIFwiLi4vZm10L2NvbG9ycy50c1wiO1xuXG5pbnRlcmZhY2UgRmFydGhlc3RQb2ludCB7XG4gIHk6IG51bWJlcjtcbiAgaWQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IERpZmZUeXBlID0ge1xuICByZW1vdmVkOiBcInJlbW92ZWRcIixcbiAgY29tbW9uOiBcImNvbW1vblwiLFxuICBhZGRlZDogXCJhZGRlZFwiLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IHR5cGUgRGlmZlR5cGUgPSBrZXlvZiB0eXBlb2YgRGlmZlR5cGU7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGlmZlJlc3VsdDxUPiB7XG4gIHR5cGU6IERpZmZUeXBlO1xuICB2YWx1ZTogVDtcbiAgZGV0YWlscz86IEFycmF5PERpZmZSZXN1bHQ8VD4+O1xufVxuXG5jb25zdCBSRU1PVkVEID0gMTtcbmNvbnN0IENPTU1PTiA9IDI7XG5jb25zdCBBRERFRCA9IDM7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbjxUPihBOiBUW10sIEI6IFRbXSwgcmV2ZXJzZT86IGJvb2xlYW4pOiBUW10ge1xuICBjb25zdCBjb21tb246IFRbXSA9IFtdO1xuICBpZiAoQS5sZW5ndGggPT09IDAgfHwgQi5sZW5ndGggPT09IDApIHJldHVybiBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbihBLmxlbmd0aCwgQi5sZW5ndGgpOyBpICs9IDEpIHtcbiAgICBjb25zdCBhID0gcmV2ZXJzZSA/IEFbQS5sZW5ndGggLSBpIC0gMV0gOiBBW2ldO1xuICAgIGNvbnN0IGIgPSByZXZlcnNlID8gQltCLmxlbmd0aCAtIGkgLSAxXSA6IEJbaV07XG4gICAgaWYgKGEgIT09IHVuZGVmaW5lZCAmJiBhID09PSBiKSB7XG4gICAgICBjb21tb24ucHVzaChhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNvbW1vbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbW1vbjtcbn1cblxuZnVuY3Rpb24gZW5zdXJlRGVmaW5lZDxUPihpdGVtPzogVCk6IFQge1xuICBpZiAoaXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJVbmV4cGVjdGVkIG1pc3NpbmcgRmFydGhlc3RQb2ludFwiKTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlc1xuICogQHBhcmFtIEEgQWN0dWFsIHZhbHVlXG4gKiBAcGFyYW0gQiBFeHBlY3RlZCB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlmZjxUPihBOiBUW10sIEI6IFRbXSk6IEFycmF5PERpZmZSZXN1bHQ8VD4+IHtcbiAgY29uc3QgcHJlZml4Q29tbW9uID0gY3JlYXRlQ29tbW9uKEEsIEIpO1xuICBjb25zdCBzdWZmaXhDb21tb24gPSBjcmVhdGVDb21tb24oXG4gICAgQS5zbGljZShwcmVmaXhDb21tb24ubGVuZ3RoKSxcbiAgICBCLnNsaWNlKHByZWZpeENvbW1vbi5sZW5ndGgpLFxuICAgIHRydWUsXG4gICkucmV2ZXJzZSgpO1xuICBBID0gc3VmZml4Q29tbW9uLmxlbmd0aFxuICAgID8gQS5zbGljZShwcmVmaXhDb21tb24ubGVuZ3RoLCAtc3VmZml4Q29tbW9uLmxlbmd0aClcbiAgICA6IEEuc2xpY2UocHJlZml4Q29tbW9uLmxlbmd0aCk7XG4gIEIgPSBzdWZmaXhDb21tb24ubGVuZ3RoXG4gICAgPyBCLnNsaWNlKHByZWZpeENvbW1vbi5sZW5ndGgsIC1zdWZmaXhDb21tb24ubGVuZ3RoKVxuICAgIDogQi5zbGljZShwcmVmaXhDb21tb24ubGVuZ3RoKTtcbiAgY29uc3Qgc3dhcHBlZCA9IEIubGVuZ3RoID4gQS5sZW5ndGg7XG4gIFtBLCBCXSA9IHN3YXBwZWQgPyBbQiwgQV0gOiBbQSwgQl07XG4gIGNvbnN0IE0gPSBBLmxlbmd0aDtcbiAgY29uc3QgTiA9IEIubGVuZ3RoO1xuICBpZiAoIU0gJiYgIU4gJiYgIXN1ZmZpeENvbW1vbi5sZW5ndGggJiYgIXByZWZpeENvbW1vbi5sZW5ndGgpIHJldHVybiBbXTtcbiAgaWYgKCFOKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC4uLnByZWZpeENvbW1vbi5tYXAoXG4gICAgICAgIChjKTogRGlmZlJlc3VsdDx0eXBlb2YgYz4gPT4gKHsgdHlwZTogRGlmZlR5cGUuY29tbW9uLCB2YWx1ZTogYyB9KSxcbiAgICAgICksXG4gICAgICAuLi5BLm1hcChcbiAgICAgICAgKGEpOiBEaWZmUmVzdWx0PHR5cGVvZiBhPiA9PiAoe1xuICAgICAgICAgIHR5cGU6IHN3YXBwZWQgPyBEaWZmVHlwZS5hZGRlZCA6IERpZmZUeXBlLnJlbW92ZWQsXG4gICAgICAgICAgdmFsdWU6IGEsXG4gICAgICAgIH0pLFxuICAgICAgKSxcbiAgICAgIC4uLnN1ZmZpeENvbW1vbi5tYXAoXG4gICAgICAgIChjKTogRGlmZlJlc3VsdDx0eXBlb2YgYz4gPT4gKHsgdHlwZTogRGlmZlR5cGUuY29tbW9uLCB2YWx1ZTogYyB9KSxcbiAgICAgICksXG4gICAgXTtcbiAgfVxuICBjb25zdCBvZmZzZXQgPSBOO1xuICBjb25zdCBkZWx0YSA9IE0gLSBOO1xuICBjb25zdCBzaXplID0gTSArIE4gKyAxO1xuICBjb25zdCBmcDogRmFydGhlc3RQb2ludFtdID0gQXJyYXkuZnJvbShcbiAgICB7IGxlbmd0aDogc2l6ZSB9LFxuICAgICgpID0+ICh7IHk6IC0xLCBpZDogLTEgfSksXG4gICk7XG5cbiAgLyoqXG4gICAqIElORk86XG4gICAqIFRoaXMgYnVmZmVyIGlzIHVzZWQgdG8gc2F2ZSBtZW1vcnkgYW5kIGltcHJvdmUgcGVyZm9ybWFuY2UuXG4gICAqIFRoZSBmaXJzdCBoYWxmIGlzIHVzZWQgdG8gc2F2ZSByb3V0ZSBhbmQgbGFzdCBoYWxmIGlzIHVzZWQgdG8gc2F2ZSBkaWZmXG4gICAqIHR5cGUuXG4gICAqIFRoaXMgaXMgYmVjYXVzZSwgd2hlbiBJIGtlcHQgbmV3IHVpbnQ4YXJyYXkgYXJlYSB0byBzYXZlIHR5cGUscGVyZm9ybWFuY2VcbiAgICogd29yc2VuZWQuXG4gICAqL1xuICBjb25zdCByb3V0ZXMgPSBuZXcgVWludDMyQXJyYXkoKE0gKiBOICsgc2l6ZSArIDEpICogMik7XG4gIGNvbnN0IGRpZmZUeXBlc1B0ck9mZnNldCA9IHJvdXRlcy5sZW5ndGggLyAyO1xuICBsZXQgcHRyID0gMDtcbiAgbGV0IHAgPSAtMTtcblxuICBmdW5jdGlvbiBiYWNrVHJhY2U8VD4oXG4gICAgQTogVFtdLFxuICAgIEI6IFRbXSxcbiAgICBjdXJyZW50OiBGYXJ0aGVzdFBvaW50LFxuICAgIHN3YXBwZWQ6IGJvb2xlYW4sXG4gICk6IEFycmF5PHtcbiAgICB0eXBlOiBEaWZmVHlwZTtcbiAgICB2YWx1ZTogVDtcbiAgfT4ge1xuICAgIGNvbnN0IE0gPSBBLmxlbmd0aDtcbiAgICBjb25zdCBOID0gQi5sZW5ndGg7XG4gICAgY29uc3QgcmVzdWx0OiB7IHR5cGU6IERpZmZUeXBlOyB2YWx1ZTogVCB9W10gPSBbXTtcbiAgICBsZXQgYSA9IE0gLSAxO1xuICAgIGxldCBiID0gTiAtIDE7XG4gICAgbGV0IGogPSByb3V0ZXNbY3VycmVudC5pZF07XG4gICAgbGV0IHR5cGUgPSByb3V0ZXNbY3VycmVudC5pZCArIGRpZmZUeXBlc1B0ck9mZnNldF07XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICghaiAmJiAhdHlwZSkgYnJlYWs7XG4gICAgICBjb25zdCBwcmV2ID0gaiE7XG4gICAgICBpZiAodHlwZSA9PT0gUkVNT1ZFRCkge1xuICAgICAgICByZXN1bHQudW5zaGlmdCh7XG4gICAgICAgICAgdHlwZTogc3dhcHBlZCA/IERpZmZUeXBlLnJlbW92ZWQgOiBEaWZmVHlwZS5hZGRlZCxcbiAgICAgICAgICB2YWx1ZTogQltiXSEsXG4gICAgICAgIH0pO1xuICAgICAgICBiIC09IDE7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEFEREVEKSB7XG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KHtcbiAgICAgICAgICB0eXBlOiBzd2FwcGVkID8gRGlmZlR5cGUuYWRkZWQgOiBEaWZmVHlwZS5yZW1vdmVkLFxuICAgICAgICAgIHZhbHVlOiBBW2FdISxcbiAgICAgICAgfSk7XG4gICAgICAgIGEgLT0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KHsgdHlwZTogRGlmZlR5cGUuY29tbW9uLCB2YWx1ZTogQVthXSEgfSk7XG4gICAgICAgIGEgLT0gMTtcbiAgICAgICAgYiAtPSAxO1xuICAgICAgfVxuICAgICAgaiA9IHJvdXRlc1twcmV2XTtcbiAgICAgIHR5cGUgPSByb3V0ZXNbcHJldiArIGRpZmZUeXBlc1B0ck9mZnNldF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVGUChcbiAgICBzbGlkZTogRmFydGhlc3RQb2ludCB8IHVuZGVmaW5lZCxcbiAgICBkb3duOiBGYXJ0aGVzdFBvaW50IHwgdW5kZWZpbmVkLFxuICAgIGs6IG51bWJlcixcbiAgICBNOiBudW1iZXIsXG4gICk6IEZhcnRoZXN0UG9pbnQge1xuICAgIGlmIChzbGlkZSAmJiBzbGlkZS55ID09PSAtMSAmJiBkb3duICYmIGRvd24ueSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiB7IHk6IDAsIGlkOiAwIH07XG4gICAgfVxuICAgIGNvbnN0IGlzQWRkaW5nID0gKGRvd24/LnkgPT09IC0xKSB8fFxuICAgICAgayA9PT0gTSB8fFxuICAgICAgKHNsaWRlPy55IHx8IDApID4gKGRvd24/LnkgfHwgMCkgKyAxO1xuICAgIGlmIChzbGlkZSAmJiBpc0FkZGluZykge1xuICAgICAgY29uc3QgcHJldiA9IHNsaWRlLmlkO1xuICAgICAgcHRyKys7XG4gICAgICByb3V0ZXNbcHRyXSA9IHByZXY7XG4gICAgICByb3V0ZXNbcHRyICsgZGlmZlR5cGVzUHRyT2Zmc2V0XSA9IEFEREVEO1xuICAgICAgcmV0dXJuIHsgeTogc2xpZGUueSwgaWQ6IHB0ciB9O1xuICAgIH0gZWxzZSBpZiAoZG93biAmJiAhaXNBZGRpbmcpIHtcbiAgICAgIGNvbnN0IHByZXYgPSBkb3duLmlkO1xuICAgICAgcHRyKys7XG4gICAgICByb3V0ZXNbcHRyXSA9IHByZXY7XG4gICAgICByb3V0ZXNbcHRyICsgZGlmZlR5cGVzUHRyT2Zmc2V0XSA9IFJFTU9WRUQ7XG4gICAgICByZXR1cm4geyB5OiBkb3duLnkgKyAxLCBpZDogcHRyIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbWlzc2luZyBGYXJ0aGVzdFBvaW50XCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNuYWtlPFQ+KFxuICAgIGs6IG51bWJlcixcbiAgICBzbGlkZTogRmFydGhlc3RQb2ludCB8IHVuZGVmaW5lZCxcbiAgICBkb3duOiBGYXJ0aGVzdFBvaW50IHwgdW5kZWZpbmVkLFxuICAgIF9vZmZzZXQ6IG51bWJlcixcbiAgICBBOiBUW10sXG4gICAgQjogVFtdLFxuICApOiBGYXJ0aGVzdFBvaW50IHtcbiAgICBjb25zdCBNID0gQS5sZW5ndGg7XG4gICAgY29uc3QgTiA9IEIubGVuZ3RoO1xuICAgIGlmIChrIDwgLU4gfHwgTSA8IGspIHJldHVybiB7IHk6IC0xLCBpZDogLTEgfTtcbiAgICBjb25zdCBmcCA9IGNyZWF0ZUZQKHNsaWRlLCBkb3duLCBrLCBNKTtcbiAgICB3aGlsZSAoZnAueSArIGsgPCBNICYmIGZwLnkgPCBOICYmIEFbZnAueSArIGtdID09PSBCW2ZwLnldKSB7XG4gICAgICBjb25zdCBwcmV2ID0gZnAuaWQ7XG4gICAgICBwdHIrKztcbiAgICAgIGZwLmlkID0gcHRyO1xuICAgICAgZnAueSArPSAxO1xuICAgICAgcm91dGVzW3B0cl0gPSBwcmV2O1xuICAgICAgcm91dGVzW3B0ciArIGRpZmZUeXBlc1B0ck9mZnNldF0gPSBDT01NT047XG4gICAgfVxuICAgIHJldHVybiBmcDtcbiAgfVxuXG4gIGxldCBjdXJyZW50RlAgPSBlbnN1cmVEZWZpbmVkPEZhcnRoZXN0UG9pbnQ+KGZwW2RlbHRhICsgb2Zmc2V0XSk7XG4gIHdoaWxlIChjdXJyZW50RlAgJiYgY3VycmVudEZQLnkgPCBOKSB7XG4gICAgcCA9IHAgKyAxO1xuICAgIGZvciAobGV0IGsgPSAtcDsgayA8IGRlbHRhOyArK2spIHtcbiAgICAgIGZwW2sgKyBvZmZzZXRdID0gc25ha2UoXG4gICAgICAgIGssXG4gICAgICAgIGZwW2sgLSAxICsgb2Zmc2V0XSxcbiAgICAgICAgZnBbayArIDEgKyBvZmZzZXRdLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIEEsXG4gICAgICAgIEIsXG4gICAgICApO1xuICAgIH1cbiAgICBmb3IgKGxldCBrID0gZGVsdGEgKyBwOyBrID4gZGVsdGE7IC0taykge1xuICAgICAgZnBbayArIG9mZnNldF0gPSBzbmFrZShcbiAgICAgICAgayxcbiAgICAgICAgZnBbayAtIDEgKyBvZmZzZXRdLFxuICAgICAgICBmcFtrICsgMSArIG9mZnNldF0sXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgQSxcbiAgICAgICAgQixcbiAgICAgICk7XG4gICAgfVxuICAgIGZwW2RlbHRhICsgb2Zmc2V0XSA9IHNuYWtlKFxuICAgICAgZGVsdGEsXG4gICAgICBmcFtkZWx0YSAtIDEgKyBvZmZzZXRdLFxuICAgICAgZnBbZGVsdGEgKyAxICsgb2Zmc2V0XSxcbiAgICAgIG9mZnNldCxcbiAgICAgIEEsXG4gICAgICBCLFxuICAgICk7XG4gICAgY3VycmVudEZQID0gZW5zdXJlRGVmaW5lZChmcFtkZWx0YSArIG9mZnNldF0pO1xuICB9XG4gIHJldHVybiBbXG4gICAgLi4ucHJlZml4Q29tbW9uLm1hcChcbiAgICAgIChjKTogRGlmZlJlc3VsdDx0eXBlb2YgYz4gPT4gKHsgdHlwZTogRGlmZlR5cGUuY29tbW9uLCB2YWx1ZTogYyB9KSxcbiAgICApLFxuICAgIC4uLmJhY2tUcmFjZShBLCBCLCBjdXJyZW50RlAsIHN3YXBwZWQpLFxuICAgIC4uLnN1ZmZpeENvbW1vbi5tYXAoXG4gICAgICAoYyk6IERpZmZSZXN1bHQ8dHlwZW9mIGM+ID0+ICh7IHR5cGU6IERpZmZUeXBlLmNvbW1vbiwgdmFsdWU6IGMgfSksXG4gICAgKSxcbiAgXTtcbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHN0cmluZ3NcbiAqIFBhcnRpYWxseSBpbnNwaXJlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rcGRlY2tlci9qc2RpZmZcbiAqIEBwYXJhbSBBIEFjdHVhbCBzdHJpbmdcbiAqIEBwYXJhbSBCIEV4cGVjdGVkIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGlmZnN0cihBOiBzdHJpbmcsIEI6IHN0cmluZyk6IERpZmZSZXN1bHQ8c3RyaW5nPltdIHtcbiAgZnVuY3Rpb24gdW5lc2NhcGUoc3RyaW5nOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIC8vIHVuZXNjYXBlIGludmlzaWJsZSBjaGFyYWN0ZXJzLlxuICAgIC8vIHJlZjogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nI2VzY2FwZV9zZXF1ZW5jZXNcbiAgICByZXR1cm4gc3RyaW5nXG4gICAgICAucmVwbGFjZUFsbChcIlxcYlwiLCBcIlxcXFxiXCIpXG4gICAgICAucmVwbGFjZUFsbChcIlxcZlwiLCBcIlxcXFxmXCIpXG4gICAgICAucmVwbGFjZUFsbChcIlxcdFwiLCBcIlxcXFx0XCIpXG4gICAgICAucmVwbGFjZUFsbChcIlxcdlwiLCBcIlxcXFx2XCIpXG4gICAgICAucmVwbGFjZUFsbCggLy8gZG9lcyBub3QgcmVtb3ZlIGxpbmUgYnJlYWtzXG4gICAgICAgIC9cXHJcXG58XFxyfFxcbi9nLFxuICAgICAgICAoc3RyKSA9PiBzdHIgPT09IFwiXFxyXCIgPyBcIlxcXFxyXCIgOiBzdHIgPT09IFwiXFxuXCIgPyBcIlxcXFxuXFxuXCIgOiBcIlxcXFxyXFxcXG5cXHJcXG5cIixcbiAgICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbml6ZShzdHJpbmc6IHN0cmluZywgeyB3b3JkRGlmZiA9IGZhbHNlIH0gPSB7fSk6IHN0cmluZ1tdIHtcbiAgICBpZiAod29yZERpZmYpIHtcbiAgICAgIC8vIFNwbGl0IHN0cmluZyBvbiB3aGl0ZXNwYWNlIHN5bWJvbHNcbiAgICAgIGNvbnN0IHRva2VucyA9IHN0cmluZy5zcGxpdCgvKFteXFxTXFxyXFxuXSt8WygpW1xcXXt9J1wiXFxyXFxuXXxcXGIpLyk7XG4gICAgICAvLyBFeHRlbmRlZCBMYXRpbiBjaGFyYWN0ZXIgc2V0XG4gICAgICBjb25zdCB3b3JkcyA9XG4gICAgICAgIC9eW2EtekEtWlxcdXtDMH0tXFx1e0ZGfVxcdXtEOH0tXFx1e0Y2fVxcdXtGOH0tXFx1ezJDNn1cXHV7MkM4fS1cXHV7MkQ3fVxcdXsyREV9LVxcdXsyRkZ9XFx1ezFFMDB9LVxcdXsxRUZGfV0rJC91O1xuXG4gICAgICAvLyBKb2luIGJvdW5kYXJ5IHNwbGl0cyB0aGF0IHdlIGRvIG5vdCBjb25zaWRlciB0byBiZSBib3VuZGFyaWVzIGFuZCBtZXJnZSBlbXB0eSBzdHJpbmdzIHN1cnJvdW5kZWQgYnkgd29yZCBjaGFyc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICBjb25zdCB0b2tlblBsdXNUd28gPSB0b2tlbnNbaSArIDJdO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIXRva2Vuc1tpICsgMV0gJiZcbiAgICAgICAgICB0b2tlbiAmJlxuICAgICAgICAgIHRva2VuUGx1c1R3byAmJlxuICAgICAgICAgIHdvcmRzLnRlc3QodG9rZW4pICYmXG4gICAgICAgICAgd29yZHMudGVzdCh0b2tlblBsdXNUd28pXG4gICAgICAgICkge1xuICAgICAgICAgIHRva2Vuc1tpXSArPSB0b2tlblBsdXNUd287XG4gICAgICAgICAgdG9rZW5zLnNwbGljZShpICsgMSwgMik7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9rZW5zLmZpbHRlcigodG9rZW4pID0+IHRva2VuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3BsaXQgc3RyaW5nIG9uIG5ldyBsaW5lcyBzeW1ib2xzXG4gICAgICBjb25zdCB0b2tlbnM6IHN0cmluZ1tdID0gW107XG4gICAgICBjb25zdCBsaW5lcyA9IHN0cmluZy5zcGxpdCgvKFxcbnxcXHJcXG4pLyk7XG5cbiAgICAgIC8vIElnbm9yZSBmaW5hbCBlbXB0eSB0b2tlbiB3aGVuIHRleHQgZW5kcyB3aXRoIGEgbmV3bGluZVxuICAgICAgaWYgKCFsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSkge1xuICAgICAgICBsaW5lcy5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWVyZ2UgdGhlIGNvbnRlbnQgYW5kIGxpbmUgc2VwYXJhdG9ycyBpbnRvIHNpbmdsZSB0b2tlbnNcbiAgICAgIGZvciAoY29uc3QgW2ksIGxpbmVdIG9mIGxpbmVzLmVudHJpZXMoKSkge1xuICAgICAgICBpZiAoaSAlIDIpIHtcbiAgICAgICAgICB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdICs9IGxpbmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGRldGFpbHMgYnkgZmlsdGVyaW5nIHJlbGV2YW50IHdvcmQtZGlmZiBmb3IgY3VycmVudCBsaW5lXG4gIC8vIGFuZCBtZXJnZSBcInNwYWNlLWRpZmZcIiBpZiBzdXJyb3VuZGVkIGJ5IHdvcmQtZGlmZiBmb3IgY2xlYW5lciBkaXNwbGF5c1xuICBmdW5jdGlvbiBjcmVhdGVEZXRhaWxzKFxuICAgIGxpbmU6IERpZmZSZXN1bHQ8c3RyaW5nPixcbiAgICB0b2tlbnM6IEFycmF5PERpZmZSZXN1bHQ8c3RyaW5nPj4sXG4gICkge1xuICAgIHJldHVybiB0b2tlbnMuZmlsdGVyKCh7IHR5cGUgfSkgPT5cbiAgICAgIHR5cGUgPT09IGxpbmUudHlwZSB8fCB0eXBlID09PSBEaWZmVHlwZS5jb21tb25cbiAgICApLm1hcCgocmVzdWx0LCBpLCB0KSA9PiB7XG4gICAgICBjb25zdCB0b2tlbiA9IHRbaSAtIDFdO1xuICAgICAgaWYgKFxuICAgICAgICAocmVzdWx0LnR5cGUgPT09IERpZmZUeXBlLmNvbW1vbikgJiYgdG9rZW4gJiZcbiAgICAgICAgKHRva2VuLnR5cGUgPT09IHRbaSArIDFdPy50eXBlKSAmJiAvXFxzKy8udGVzdChyZXN1bHQudmFsdWUpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgdHlwZTogdG9rZW4udHlwZSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gIH1cblxuICAvLyBDb21wdXRlIG11bHRpLWxpbmUgZGlmZlxuICBjb25zdCBkaWZmUmVzdWx0ID0gZGlmZihcbiAgICB0b2tlbml6ZShgJHt1bmVzY2FwZShBKX1cXG5gKSxcbiAgICB0b2tlbml6ZShgJHt1bmVzY2FwZShCKX1cXG5gKSxcbiAgKTtcblxuICBjb25zdCBhZGRlZCA9IFtdO1xuICBjb25zdCByZW1vdmVkID0gW107XG4gIGZvciAoY29uc3QgcmVzdWx0IG9mIGRpZmZSZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0LnR5cGUgPT09IERpZmZUeXBlLmFkZGVkKSB7XG4gICAgICBhZGRlZC5wdXNoKHJlc3VsdCk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQudHlwZSA9PT0gRGlmZlR5cGUucmVtb3ZlZCkge1xuICAgICAgcmVtb3ZlZC5wdXNoKHJlc3VsdCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tcHV0ZSB3b3JkLWRpZmZcbiAgY29uc3QgaGFzTW9yZVJlbW92ZWRMaW5lcyA9IGFkZGVkLmxlbmd0aCA8IHJlbW92ZWQubGVuZ3RoO1xuICBjb25zdCBhTGluZXMgPSBoYXNNb3JlUmVtb3ZlZExpbmVzID8gYWRkZWQgOiByZW1vdmVkO1xuICBjb25zdCBiTGluZXMgPSBoYXNNb3JlUmVtb3ZlZExpbmVzID8gcmVtb3ZlZCA6IGFkZGVkO1xuICBmb3IgKGNvbnN0IGEgb2YgYUxpbmVzKSB7XG4gICAgbGV0IHRva2VucyA9IFtdIGFzIEFycmF5PERpZmZSZXN1bHQ8c3RyaW5nPj47XG4gICAgbGV0IGI6IHVuZGVmaW5lZCB8IERpZmZSZXN1bHQ8c3RyaW5nPjtcbiAgICAvLyBTZWFyY2ggYW5vdGhlciBkaWZmIGxpbmUgd2l0aCBhdCBsZWFzdCBvbmUgY29tbW9uIHRva2VuXG4gICAgd2hpbGUgKGJMaW5lcy5sZW5ndGgpIHtcbiAgICAgIGIgPSBiTGluZXMuc2hpZnQoKTtcbiAgICAgIGNvbnN0IHRva2VuaXplZCA9IFtcbiAgICAgICAgdG9rZW5pemUoYS52YWx1ZSwgeyB3b3JkRGlmZjogdHJ1ZSB9KSxcbiAgICAgICAgdG9rZW5pemUoYj8udmFsdWUgPz8gXCJcIiwgeyB3b3JkRGlmZjogdHJ1ZSB9KSxcbiAgICAgIF0gYXMgW3N0cmluZ1tdLCBzdHJpbmdbXV07XG4gICAgICBpZiAoaGFzTW9yZVJlbW92ZWRMaW5lcykgdG9rZW5pemVkLnJldmVyc2UoKTtcbiAgICAgIHRva2VucyA9IGRpZmYodG9rZW5pemVkWzBdLCB0b2tlbml6ZWRbMV0pO1xuICAgICAgaWYgKFxuICAgICAgICB0b2tlbnMuc29tZSgoeyB0eXBlLCB2YWx1ZSB9KSA9PlxuICAgICAgICAgIHR5cGUgPT09IERpZmZUeXBlLmNvbW1vbiAmJiB2YWx1ZS50cmltKCkubGVuZ3RoXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVnaXN0ZXIgd29yZC1kaWZmIGRldGFpbHNcbiAgICBhLmRldGFpbHMgPSBjcmVhdGVEZXRhaWxzKGEsIHRva2Vucyk7XG4gICAgaWYgKGIpIHtcbiAgICAgIGIuZGV0YWlscyA9IGNyZWF0ZURldGFpbHMoYiwgdG9rZW5zKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlmZlJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb2xvcnMgdGhlIG91dHB1dCBvZiBhc3NlcnRpb24gZGlmZnNcbiAqIEBwYXJhbSBkaWZmVHlwZSBEaWZmZXJlbmNlIHR5cGUsIGVpdGhlciBhZGRlZCBvciByZW1vdmVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbG9yKFxuICBkaWZmVHlwZTogRGlmZlR5cGUsXG4gIHsgYmFja2dyb3VuZCA9IGZhbHNlIH0gPSB7fSxcbik6IChzOiBzdHJpbmcpID0+IHN0cmluZyB7XG4gIC8vIFRPRE8oQGxpdHRsZWRpdnkpOiBSZW1vdmUgdGhpcyB3aGVuIHdlIGNhbiBkZXRlY3RcbiAgLy8gdHJ1ZSBjb2xvciB0ZXJtaW5hbHMuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZW5vbGFuZC9kZW5vX3N0ZC9pc3N1ZXMvMjU3NVxuICBiYWNrZ3JvdW5kID0gZmFsc2U7XG4gIHN3aXRjaCAoZGlmZlR5cGUpIHtcbiAgICBjYXNlIERpZmZUeXBlLmFkZGVkOlxuICAgICAgcmV0dXJuIChzOiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAgICAgICAgYmFja2dyb3VuZCA/IGJnR3JlZW4od2hpdGUocykpIDogZ3JlZW4oYm9sZChzKSk7XG4gICAgY2FzZSBEaWZmVHlwZS5yZW1vdmVkOlxuICAgICAgcmV0dXJuIChzOiBzdHJpbmcpOiBzdHJpbmcgPT4gYmFja2dyb3VuZCA/IGJnUmVkKHdoaXRlKHMpKSA6IHJlZChib2xkKHMpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHdoaXRlO1xuICB9XG59XG5cbi8qKlxuICogUHJlZml4ZXMgYCtgIG9yIGAtYCBpbiBkaWZmIG91dHB1dFxuICogQHBhcmFtIGRpZmZUeXBlIERpZmZlcmVuY2UgdHlwZSwgZWl0aGVyIGFkZGVkIG9yIHJlbW92ZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2lnbihkaWZmVHlwZTogRGlmZlR5cGUpOiBzdHJpbmcge1xuICBzd2l0Y2ggKGRpZmZUeXBlKSB7XG4gICAgY2FzZSBEaWZmVHlwZS5hZGRlZDpcbiAgICAgIHJldHVybiBcIisgICBcIjtcbiAgICBjYXNlIERpZmZUeXBlLnJlbW92ZWQ6XG4gICAgICByZXR1cm4gXCItICAgXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcIiAgICBcIjtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRNZXNzYWdlKFxuICBkaWZmUmVzdWx0OiBSZWFkb25seUFycmF5PERpZmZSZXN1bHQ8c3RyaW5nPj4sXG4gIHsgc3RyaW5nRGlmZiA9IGZhbHNlIH0gPSB7fSxcbik6IHN0cmluZ1tdIHtcbiAgY29uc3QgbWVzc2FnZXM6IHN0cmluZ1tdID0gW107XG4gIGNvbnN0IGRpZmZNZXNzYWdlczogc3RyaW5nW10gPSBbXTtcbiAgbWVzc2FnZXMucHVzaChcIlwiKTtcbiAgbWVzc2FnZXMucHVzaChcIlwiKTtcbiAgbWVzc2FnZXMucHVzaChcbiAgICBgICAgICR7Z3JheShib2xkKFwiW0RpZmZdXCIpKX0gJHtyZWQoYm9sZChcIkFjdHVhbFwiKSl9IC8gJHtcbiAgICAgIGdyZWVuKGJvbGQoXCJFeHBlY3RlZFwiKSlcbiAgICB9YCxcbiAgKTtcbiAgbWVzc2FnZXMucHVzaChcIlwiKTtcbiAgbWVzc2FnZXMucHVzaChcIlwiKTtcbiAgZGlmZlJlc3VsdC5mb3JFYWNoKChyZXN1bHQ6IERpZmZSZXN1bHQ8c3RyaW5nPikgPT4ge1xuICAgIGNvbnN0IGMgPSBjcmVhdGVDb2xvcihyZXN1bHQudHlwZSk7XG4gICAgY29uc3QgbGluZSA9IHJlc3VsdC5kZXRhaWxzPy5tYXAoKGRldGFpbCkgPT5cbiAgICAgIGRldGFpbC50eXBlICE9PSBEaWZmVHlwZS5jb21tb25cbiAgICAgICAgPyBjcmVhdGVDb2xvcihkZXRhaWwudHlwZSwgeyBiYWNrZ3JvdW5kOiB0cnVlIH0pKGRldGFpbC52YWx1ZSlcbiAgICAgICAgOiBkZXRhaWwudmFsdWVcbiAgICApLmpvaW4oXCJcIikgPz8gcmVzdWx0LnZhbHVlO1xuICAgIGRpZmZNZXNzYWdlcy5wdXNoKGMoYCR7Y3JlYXRlU2lnbihyZXN1bHQudHlwZSl9JHtsaW5lfWApKTtcbiAgfSk7XG4gIG1lc3NhZ2VzLnB1c2goLi4uKHN0cmluZ0RpZmYgPyBbZGlmZk1lc3NhZ2VzLmpvaW4oXCJcIildIDogZGlmZk1lc3NhZ2VzKSk7XG4gIG1lc3NhZ2VzLnB1c2goXCJcIik7XG5cbiAgcmV0dXJuIG1lc3NhZ2VzO1xufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDBFQUEwRTtBQUMxRSxxQ0FBcUM7QUFFckMsU0FDRSxPQUFPLEVBQ1AsS0FBSyxFQUNMLElBQUksRUFDSixJQUFJLEVBQ0osS0FBSyxFQUNMLEdBQUcsRUFDSCxLQUFLLFFBQ0EsbUJBQW1CO0FBTzFCLE9BQU8sTUFBTSxXQUFXO0VBQ3RCLFNBQVM7RUFDVCxRQUFRO0VBQ1IsT0FBTztBQUNULEVBQVc7QUFVWCxNQUFNLFVBQVU7QUFDaEIsTUFBTSxTQUFTO0FBQ2YsTUFBTSxRQUFRO0FBRWQsU0FBUyxhQUFnQixDQUFNLEVBQUUsQ0FBTSxFQUFFLE9BQWlCO0VBQ3hELE1BQU0sU0FBYyxFQUFFO0VBQ3RCLElBQUksRUFBRSxNQUFNLEtBQUssS0FBSyxF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
// denoCacheMetadata=7995908025359747892,7812650556526581519