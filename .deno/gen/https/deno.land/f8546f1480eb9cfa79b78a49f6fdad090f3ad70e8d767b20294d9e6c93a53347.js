import { brightBlue, underline } from "./deps.ts";
import { GenericList, isOption, isOptionGroup } from "./_generic_list.ts";
import { GenericPrompt } from "./_generic_prompt.ts";
import { getFiguresByKeys } from "./_figures.ts";
/**
 * Select prompt representation.
 *
 * Simple prompt:
 *
 * ```ts
 * import { Select } from "./mod.ts";
 *
 * const color: string = await Select.prompt({
 *   message: "Pick a color",
 *   options: ["red", "green", "blue"],
 * });
 * ```
 *
 * Mixed option types:
 *
 * ```ts
 * import { Select } from "./mod.ts";
 *
 * const value: string | number = await Select.prompt<string | number>({
 *   message: "Pick a color",
 *   options: [1, 2, "3", "4"],
 * });
 * ```
 *
 * None primitive option types:
 *
 * ```ts
 * import { Select } from "./mod.ts";
 *
 * const date: Date = await Select.prompt({
 *   message: "Pick a date",
 *   options: [
 *     {
 *       name: "Date 1",
 *       value: new Date(100000),
 *     },
 *     {
 *       name: "Date 2",
 *       value: new Date(200000),
 *     },
 *     {
 *       name: "Date 3",
 *       value: new Date(300000),
 *     },
 *   ],
 * });
 * ```
 *
 * Grouped options:
 *
 * ```ts
 * import { Select } from "./mod.ts";
 *
 * const value = await Select.prompt({
 *   message: "Select a value",
 *   options: [{
 *     name: "Group 1",
 *     options: ["foo", "bar", "baz"],
 *   }, {
 *     name: "Group 2",
 *     options: ["beep", "boop"],
 *   }],
 * });
 * ```
 */ export class Select extends GenericList {
  settings;
  options;
  listIndex;
  listOffset;
  /** Execute the prompt with provided options. */ static prompt(options) {
    return new this(options).prompt();
  }
  /**
   * Inject prompt value. If called, the prompt doesn't prompt for an input and
   * returns immediately the injected value. Can be used for unit tests or pre
   * selections.
   *
   * @param value Input value.
   */ static inject(value) {
    GenericPrompt.inject(value);
  }
  constructor(options){
    super();
    this.settings = this.getDefaultSettings(options);
    this.options = this.settings.options.slice();
    this.listIndex = this.getListIndex(this.settings.default);
    this.listOffset = this.getPageOffset(this.listIndex);
  }
  getDefaultSettings(options) {
    return {
      ...super.getDefaultSettings(options),
      options: this.mapOptions(options, options.options)
    };
  }
  /** Map string option values to options and set option defaults. */ mapOptions(promptOptions, options) {
    return options.map((option)=>isSelectOptionGroup(option) ? this.mapOptionGroup(promptOptions, option) : typeof option === "string" || typeof option === "number" ? this.mapOption(promptOptions, {
        value: option
      }) : this.mapOption(promptOptions, option));
  }
  input() {
    return underline(brightBlue(this.inputValue));
  }
  async submit() {
    if (this.isBackButton(this.selectedOption) || isOptionGroup(this.selectedOption)) {
      const info = isOptionGroup(this.selectedOption) ? ` To select a group use ${getFiguresByKeys(this.settings.keys.open ?? []).join(", ")}.` : "";
      this.setErrorMessage(`No option selected.${info}`);
      return;
    }
    await super.submit();
  }
  /** Get value of selected option. */ getValue() {
    const option = this.options[this.listIndex];
    assertIsOption(option);
    return option.value;
  }
  /**
   * Validate input value.
   * @param value User input value.
   * @return True on success, false or error message on error.
   */ validate(value) {
    return this.options.findIndex((option)=>isOption(option) && option.value === value) !== -1;
  }
  /**
   * Map input value to output value.
   * @param value Input value.
   * @return Output value.
   */ transform(value) {
    return value;
  }
  /**
   * Format output value.
   * @param value Output value.
   */ format(value) {
    return this.settings.format?.(value) ?? this.getOptionByValue(value)?.name ?? String(value);
  }
}
function assertIsOption(option) {
  if (!isOption(option)) {
    throw new Error("Expected an option but got an option group.");
  }
}
export function isSelectOptionGroup(option) {
  return isOptionGroup(option);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vZGVuby5sYW5kL3gvY2xpZmZ5QHYxLjAuMC1yYy4zL3Byb21wdC9zZWxlY3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgV2lkZW5UeXBlIH0gZnJvbSBcIi4vX3V0aWxzLnRzXCI7XG5pbXBvcnQgeyBicmlnaHRCbHVlLCB1bmRlcmxpbmUgfSBmcm9tIFwiLi9kZXBzLnRzXCI7XG5pbXBvcnQge1xuICBHZW5lcmljTGlzdCxcbiAgR2VuZXJpY0xpc3RLZXlzLFxuICBHZW5lcmljTGlzdE9wdGlvbixcbiAgR2VuZXJpY0xpc3RPcHRpb25Hcm91cCxcbiAgR2VuZXJpY0xpc3RPcHRpb25Hcm91cFNldHRpbmdzLFxuICBHZW5lcmljTGlzdE9wdGlvbnMsXG4gIEdlbmVyaWNMaXN0T3B0aW9uU2V0dGluZ3MsXG4gIEdlbmVyaWNMaXN0U2VwYXJhdG9yT3B0aW9uLFxuICBHZW5lcmljTGlzdFNldHRpbmdzLFxuICBpc09wdGlvbixcbiAgaXNPcHRpb25Hcm91cCxcbn0gZnJvbSBcIi4vX2dlbmVyaWNfbGlzdC50c1wiO1xuaW1wb3J0IHsgR2VuZXJpY1Byb21wdCB9IGZyb20gXCIuL19nZW5lcmljX3Byb21wdC50c1wiO1xuaW1wb3J0IHsgZ2V0RmlndXJlc0J5S2V5cyB9IGZyb20gXCIuL19maWd1cmVzLnRzXCI7XG5cbi8qKiBTZWxlY3QgcHJvbXB0IG9wdGlvbnMuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdE9wdGlvbnM8VFZhbHVlPlxuICBleHRlbmRzIEdlbmVyaWNMaXN0T3B0aW9uczxUVmFsdWUsIFRWYWx1ZSwgVFZhbHVlPiB7XG4gIC8qKiBLZXltYXAgdG8gYXNzaWduIGtleSBuYW1lcyB0byBwcm9tcHQgYWN0aW9ucy4gKi9cbiAga2V5cz86IFNlbGVjdEtleXM7XG4gIC8qKiBBbiBhcnJheSBvZiBjaGlsZCBvcHRpb25zLiAqL1xuICBvcHRpb25zOiBBcnJheTxcbiAgICB8IEV4dHJhY3Q8VFZhbHVlLCBzdHJpbmcgfCBudW1iZXI+XG4gICAgfCBFeHRyYWN0PFdpZGVuVHlwZTxUVmFsdWU+LCBzdHJpbmcgfCBudW1iZXI+XG4gICAgfCBTZWxlY3RPcHRpb248VFZhbHVlPlxuICAgIHwgU2VsZWN0T3B0aW9uR3JvdXA8VFZhbHVlPlxuICAgIHwgR2VuZXJpY0xpc3RTZXBhcmF0b3JPcHRpb25cbiAgPjtcbn1cblxuLyoqIFNlbGVjdCBwcm9tcHQgc2V0dGluZ3MuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdFNldHRpbmdzPFRWYWx1ZT4gZXh0ZW5kc1xuICBHZW5lcmljTGlzdFNldHRpbmdzPFxuICAgIFRWYWx1ZSxcbiAgICBUVmFsdWUsXG4gICAgVFZhbHVlLFxuICAgIFNlbGVjdE9wdGlvblNldHRpbmdzPFRWYWx1ZT4sXG4gICAgU2VsZWN0T3B0aW9uR3JvdXBTZXR0aW5nczxUVmFsdWU+XG4gID4ge1xuICBrZXlzOiBTZWxlY3RLZXlzO1xufVxuXG4vKiogU2VsZWN0IG9wdGlvbiBvcHRpb25zLiAqL1xuZXhwb3J0IHR5cGUgU2VsZWN0T3B0aW9uPFRWYWx1ZT4gPSBHZW5lcmljTGlzdE9wdGlvbjxUVmFsdWU+O1xuXG4vKiogU2VsZWN0IG9wdGlvbiBncm91cCBvcHRpb25zLiAqL1xuZXhwb3J0IHR5cGUgU2VsZWN0T3B0aW9uR3JvdXA8VFZhbHVlPiA9IEdlbmVyaWNMaXN0T3B0aW9uR3JvdXA8XG4gIFRWYWx1ZSxcbiAgR2VuZXJpY0xpc3RPcHRpb248VFZhbHVlPlxuPjtcblxuLyoqIFNlbGVjdCBvcHRpb24gc2V0dGluZ3MuICovXG5leHBvcnQgdHlwZSBTZWxlY3RPcHRpb25TZXR0aW5nczxUVmFsdWU+ID0gR2VuZXJpY0xpc3RPcHRpb25TZXR0aW5nczxUVmFsdWU+O1xuXG4vKiogU2VsZWN0IG9wdGlvbiBncm91cCBzZXR0aW5ncy4gKi9cbmV4cG9ydCB0eXBlIFNlbGVjdE9wdGlvbkdyb3VwU2V0dGluZ3M8VFZhbHVlPiA9IEdlbmVyaWNMaXN0T3B0aW9uR3JvdXBTZXR0aW5nczxcbiAgVFZhbHVlLFxuICBTZWxlY3RPcHRpb25TZXR0aW5nczxUVmFsdWU+XG4+O1xuXG4vKiogU2VsZWN0IHByb21wdCBrZXltYXAuICovXG5leHBvcnQgdHlwZSBTZWxlY3RLZXlzID0gR2VuZXJpY0xpc3RLZXlzO1xuXG4vKipcbiAqIFNlbGVjdCBwcm9tcHQgcmVwcmVzZW50YXRpb24uXG4gKlxuICogU2ltcGxlIHByb21wdDpcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgU2VsZWN0IH0gZnJvbSBcIi4vbW9kLnRzXCI7XG4gKlxuICogY29uc3QgY29sb3I6IHN0cmluZyA9IGF3YWl0IFNlbGVjdC5wcm9tcHQoe1xuICogICBtZXNzYWdlOiBcIlBpY2sgYSBjb2xvclwiLFxuICogICBvcHRpb25zOiBbXCJyZWRcIiwgXCJncmVlblwiLCBcImJsdWVcIl0sXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIE1peGVkIG9wdGlvbiB0eXBlczpcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgU2VsZWN0IH0gZnJvbSBcIi4vbW9kLnRzXCI7XG4gKlxuICogY29uc3QgdmFsdWU6IHN0cmluZyB8IG51bWJlciA9IGF3YWl0IFNlbGVjdC5wcm9tcHQ8c3RyaW5nIHwgbnVtYmVyPih7XG4gKiAgIG1lc3NhZ2U6IFwiUGljayBhIGNvbG9yXCIsXG4gKiAgIG9wdGlvbnM6IFsxLCAyLCBcIjNcIiwgXCI0XCJdLFxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBOb25lIHByaW1pdGl2ZSBvcHRpb24gdHlwZXM6XG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IFNlbGVjdCB9IGZyb20gXCIuL21vZC50c1wiO1xuICpcbiAqIGNvbnN0IGRhdGU6IERhdGUgPSBhd2FpdCBTZWxlY3QucHJvbXB0KHtcbiAqICAgbWVzc2FnZTogXCJQaWNrIGEgZGF0ZVwiLFxuICogICBvcHRpb25zOiBbXG4gKiAgICAge1xuICogICAgICAgbmFtZTogXCJEYXRlIDFcIixcbiAqICAgICAgIHZhbHVlOiBuZXcgRGF0ZSgxMDAwMDApLFxuICogICAgIH0sXG4gKiAgICAge1xuICogICAgICAgbmFtZTogXCJEYXRlIDJcIixcbiAqICAgICAgIHZhbHVlOiBuZXcgRGF0ZSgyMDAwMDApLFxuICogICAgIH0sXG4gKiAgICAge1xuICogICAgICAgbmFtZTogXCJEYXRlIDNcIixcbiAqICAgICAgIHZhbHVlOiBuZXcgRGF0ZSgzMDAwMDApLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEdyb3VwZWQgb3B0aW9uczpcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgU2VsZWN0IH0gZnJvbSBcIi4vbW9kLnRzXCI7XG4gKlxuICogY29uc3QgdmFsdWUgPSBhd2FpdCBTZWxlY3QucHJvbXB0KHtcbiAqICAgbWVzc2FnZTogXCJTZWxlY3QgYSB2YWx1ZVwiLFxuICogICBvcHRpb25zOiBbe1xuICogICAgIG5hbWU6IFwiR3JvdXAgMVwiLFxuICogICAgIG9wdGlvbnM6IFtcImZvb1wiLCBcImJhclwiLCBcImJhelwiXSxcbiAqICAgfSwge1xuICogICAgIG5hbWU6IFwiR3JvdXAgMlwiLFxuICogICAgIG9wdGlvbnM6IFtcImJlZXBcIiwgXCJib29wXCJdLFxuICogICB9XSxcbiAqIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBTZWxlY3Q8VFZhbHVlPiBleHRlbmRzIEdlbmVyaWNMaXN0PFxuICBUVmFsdWUsXG4gIFRWYWx1ZSxcbiAgVFZhbHVlLFxuICBTZWxlY3RPcHRpb25TZXR0aW5nczxUVmFsdWU+LFxuICBTZWxlY3RPcHRpb25Hcm91cFNldHRpbmdzPFRWYWx1ZT5cbj4ge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgc2V0dGluZ3M6IFNlbGVjdFNldHRpbmdzPFRWYWx1ZT47XG4gIHByb3RlY3RlZCBvcHRpb25zOiBBcnJheTxcbiAgICBTZWxlY3RPcHRpb25TZXR0aW5nczxUVmFsdWU+IHwgU2VsZWN0T3B0aW9uR3JvdXBTZXR0aW5nczxUVmFsdWU+XG4gID47XG4gIHByb3RlY3RlZCBsaXN0SW5kZXg6IG51bWJlcjtcbiAgcHJvdGVjdGVkIGxpc3RPZmZzZXQ6IG51bWJlcjtcblxuICAvKiogRXhlY3V0ZSB0aGUgcHJvbXB0IHdpdGggcHJvdmlkZWQgb3B0aW9ucy4gKi9cbiAgcHVibGljIHN0YXRpYyBwcm9tcHQ8VFZhbHVlPihcbiAgICBvcHRpb25zOiBTZWxlY3RPcHRpb25zPFRWYWx1ZT4sXG4gICk6IFByb21pc2U8V2lkZW5UeXBlPFRWYWx1ZT4+IHtcbiAgICByZXR1cm4gbmV3IHRoaXMob3B0aW9ucykucHJvbXB0KCkgYXMgUHJvbWlzZTxXaWRlblR5cGU8VFZhbHVlPj47XG4gIH1cblxuICAvKipcbiAgICogSW5qZWN0IHByb21wdCB2YWx1ZS4gSWYgY2FsbGVkLCB0aGUgcHJvbXB0IGRvZXNuJ3QgcHJvbXB0IGZvciBhbiBpbnB1dCBhbmRcbiAgICogcmV0dXJucyBpbW1lZGlhdGVseSB0aGUgaW5qZWN0ZWQgdmFsdWUuIENhbiBiZSB1c2VkIGZvciB1bml0IHRlc3RzIG9yIHByZVxuICAgKiBzZWxlY3Rpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgSW5wdXQgdmFsdWUuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGluamVjdCh2YWx1ZTogc3RyaW5nKTogdm9pZCB7XG4gICAgR2VuZXJpY1Byb21wdC5pbmplY3QodmFsdWUpO1xuICB9XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogU2VsZWN0T3B0aW9uczxUVmFsdWU+KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNldHRpbmdzID0gdGhpcy5nZXREZWZhdWx0U2V0dGluZ3Mob3B0aW9ucyk7XG4gICAgdGhpcy5vcHRpb25zID0gdGhpcy5zZXR0aW5ncy5vcHRpb25zLnNsaWNlKCk7XG4gICAgdGhpcy5saXN0SW5kZXggPSB0aGlzLmdldExpc3RJbmRleCh0aGlzLnNldHRpbmdzLmRlZmF1bHQpO1xuICAgIHRoaXMubGlzdE9mZnNldCA9IHRoaXMuZ2V0UGFnZU9mZnNldCh0aGlzLmxpc3RJbmRleCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0RGVmYXVsdFNldHRpbmdzKFxuICAgIG9wdGlvbnM6IFNlbGVjdE9wdGlvbnM8VFZhbHVlPixcbiAgKTogU2VsZWN0U2V0dGluZ3M8VFZhbHVlPiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmdldERlZmF1bHRTZXR0aW5ncyhvcHRpb25zKSxcbiAgICAgIG9wdGlvbnM6IHRoaXMubWFwT3B0aW9ucyhvcHRpb25zLCBvcHRpb25zLm9wdGlvbnMpLFxuICAgIH07XG4gIH1cblxuICAvKiogTWFwIHN0cmluZyBvcHRpb24gdmFsdWVzIHRvIG9wdGlvbnMgYW5kIHNldCBvcHRpb24gZGVmYXVsdHMuICovXG4gIHByb3RlY3RlZCBtYXBPcHRpb25zKFxuICAgIHByb21wdE9wdGlvbnM6IFNlbGVjdE9wdGlvbnM8VFZhbHVlPixcbiAgICBvcHRpb25zOiBBcnJheTxcbiAgICAgIHwgRXh0cmFjdDxUVmFsdWUsIHN0cmluZyB8IG51bWJlcj5cbiAgICAgIHwgRXh0cmFjdDxXaWRlblR5cGU8VFZhbHVlPiwgc3RyaW5nIHwgbnVtYmVyPlxuICAgICAgfCBTZWxlY3RPcHRpb248VFZhbHVlPlxuICAgICAgfCBTZWxlY3RPcHRpb25Hcm91cDxUVmFsdWU+XG4gICAgICB8IEdlbmVyaWNMaXN0U2VwYXJhdG9yT3B0aW9uXG4gICAgPixcbiAgKTogQXJyYXk8U2VsZWN0T3B0aW9uU2V0dGluZ3M8VFZhbHVlPiB8IFNlbGVjdE9wdGlvbkdyb3VwU2V0dGluZ3M8VFZhbHVlPj4ge1xuICAgIHJldHVybiBvcHRpb25zLm1hcCgob3B0aW9uKSA9PlxuICAgICAgaXNTZWxlY3RPcHRpb25Hcm91cChvcHRpb24pXG4gICAgICAgID8gdGhpcy5tYXBPcHRpb25Hcm91cChwcm9tcHRPcHRpb25zLCBvcHRpb24pXG4gICAgICAgIDogdHlwZW9mIG9wdGlvbiA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2Ygb3B0aW9uID09PSBcIm51bWJlclwiXG4gICAgICAgID8gdGhpcy5tYXBPcHRpb24oXG4gICAgICAgICAgcHJvbXB0T3B0aW9ucyxcbiAgICAgICAgICB7IHZhbHVlOiBvcHRpb24gYXMgVFZhbHVlIH0sXG4gICAgICAgIClcbiAgICAgICAgOiB0aGlzLm1hcE9wdGlvbihwcm9tcHRPcHRpb25zLCBvcHRpb24pXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBpbnB1dCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB1bmRlcmxpbmUoYnJpZ2h0Qmx1ZSh0aGlzLmlucHV0VmFsdWUpKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBzdWJtaXQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5pc0JhY2tCdXR0b24odGhpcy5zZWxlY3RlZE9wdGlvbikgfHxcbiAgICAgIGlzT3B0aW9uR3JvdXAodGhpcy5zZWxlY3RlZE9wdGlvbilcbiAgICApIHtcbiAgICAgIGNvbnN0IGluZm8gPSBpc09wdGlvbkdyb3VwKHRoaXMuc2VsZWN0ZWRPcHRpb24pXG4gICAgICAgID8gYCBUbyBzZWxlY3QgYSBncm91cCB1c2UgJHtcbiAgICAgICAgICBnZXRGaWd1cmVzQnlLZXlzKHRoaXMuc2V0dGluZ3Mua2V5cy5vcGVuID8/IFtdKS5qb2luKFwiLCBcIilcbiAgICAgICAgfS5gXG4gICAgICAgIDogXCJcIjtcbiAgICAgIHRoaXMuc2V0RXJyb3JNZXNzYWdlKGBObyBvcHRpb24gc2VsZWN0ZWQuJHtpbmZvfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGF3YWl0IHN1cGVyLnN1Ym1pdCgpO1xuICB9XG5cbiAgLyoqIEdldCB2YWx1ZSBvZiBzZWxlY3RlZCBvcHRpb24uICovXG4gIHByb3RlY3RlZCBnZXRWYWx1ZSgpOiBUVmFsdWUge1xuICAgIGNvbnN0IG9wdGlvbiA9IHRoaXMub3B0aW9uc1t0aGlzLmxpc3RJbmRleF07XG4gICAgYXNzZXJ0SXNPcHRpb24ob3B0aW9uKTtcbiAgICByZXR1cm4gb3B0aW9uLnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGlucHV0IHZhbHVlLlxuICAgKiBAcGFyYW0gdmFsdWUgVXNlciBpbnB1dCB2YWx1ZS5cbiAgICogQHJldHVybiBUcnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIG9yIGVycm9yIG1lc3NhZ2Ugb24gZXJyb3IuXG4gICAqL1xuICBwcm90ZWN0ZWQgdmFsaWRhdGUodmFsdWU6IFRWYWx1ZSk6IGJvb2xlYW4gfCBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZmluZEluZGV4KChcbiAgICAgIG9wdGlvbjogU2VsZWN0T3B0aW9uU2V0dGluZ3M8VFZhbHVlPiB8IFNlbGVjdE9wdGlvbkdyb3VwU2V0dGluZ3M8VFZhbHVlPixcbiAgICApID0+IGlzT3B0aW9uKG9wdGlvbikgJiYgb3B0aW9uLnZhbHVlID09PSB2YWx1ZSkgIT09IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hcCBpbnB1dCB2YWx1ZSB0byBvdXRwdXQgdmFsdWUuXG4gICAqIEBwYXJhbSB2YWx1ZSBJbnB1dCB2YWx1ZS5cbiAgICogQHJldHVybiBPdXRwdXQgdmFsdWUuXG4gICAqL1xuICBwcm90ZWN0ZWQgdHJhbnNmb3JtKHZhbHVlOiBUVmFsdWUpOiBUVmFsdWUge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JtYXQgb3V0cHV0IHZhbHVlLlxuICAgKiBAcGFyYW0gdmFsdWUgT3V0cHV0IHZhbHVlLlxuICAgKi9cbiAgcHJvdGVjdGVkIGZvcm1hdCh2YWx1ZTogVFZhbHVlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5mb3JtYXQ/Lih2YWx1ZSkgPz9cbiAgICAgIHRoaXMuZ2V0T3B0aW9uQnlWYWx1ZSh2YWx1ZSk/Lm5hbWUgPz8gU3RyaW5nKHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRJc09wdGlvbjxcbiAgVFZhbHVlLFxuICBUT3B0aW9uIGV4dGVuZHMgR2VuZXJpY0xpc3RPcHRpb248VFZhbHVlPixcbj4oXG4gIG9wdGlvbjogVE9wdGlvbiB8IEdlbmVyaWNMaXN0T3B0aW9uR3JvdXA8VFZhbHVlLCBHZW5lcmljTGlzdE9wdGlvbjxUVmFsdWU+Pixcbik6IGFzc2VydHMgb3B0aW9uIGlzIFRPcHRpb24ge1xuICBpZiAoIWlzT3B0aW9uKG9wdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBhbiBvcHRpb24gYnV0IGdvdCBhbiBvcHRpb24gZ3JvdXAuXCIpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1NlbGVjdE9wdGlvbkdyb3VwKFxuICBvcHRpb246IHVua25vd24sXG4gIC8vIGRlbm8tbGludC1pZ25vcmUgbm8tZXhwbGljaXQtYW55XG4pOiBvcHRpb24gaXMgU2VsZWN0T3B0aW9uR3JvdXA8YW55PiB7XG4gIHJldHVybiBpc09wdGlvbkdyb3VwKG9wdGlvbik7XG59XG5cbi8qKlxuICogU2VsZWN0IG9wdGlvbnMgdHlwZS5cbiAqIEBkZXByZWNhdGVkIFVzZSBgQXJyYXk8c3RyaW5nIHwgU2VsZWN0T3B0aW9uIHwgU2VsZWN0T3B0aW9uR3JvdXA+YCBpbnN0ZWFkLlxuICovXG5leHBvcnQgdHlwZSBTZWxlY3RWYWx1ZU9wdGlvbnMgPSBBcnJheTxcbiAgc3RyaW5nIHwgU2VsZWN0T3B0aW9uPHN0cmluZz4gfCBTZWxlY3RPcHRpb25Hcm91cDxzdHJpbmc+XG4+O1xuXG4vKipcbiAqIFNlbGVjdCBvcHRpb24gc2V0dGluZ3MgdHlwZS5cbiAqIEBkZXByZWNhdGVkIFVzZSBgQXJyYXk8U2VsZWN0T3B0aW9uU2V0dGluZ3MgfCBTZWxlY3RPcHRpb25Hcm91cFNldHRpbmdzPmAgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IHR5cGUgU2VsZWN0VmFsdWVTZXR0aW5ncyA9IEFycmF5PFxuICBTZWxlY3RPcHRpb25TZXR0aW5nczxzdHJpbmc+IHwgU2VsZWN0T3B0aW9uR3JvdXBTZXR0aW5nczxzdHJpbmc+XG4+O1xuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLFNBQVMsVUFBVSxFQUFFLFNBQVMsUUFBUSxZQUFZO0FB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
// denoCacheMetadata=4665342658072128570,14021613829586146318