// Copyright 2018-2023 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { bgGreen, bgRed, bold, gray, green, red, white } from "../fmt/colors.ts";
export var DiffType;
(function(DiffType) {
  DiffType["removed"] = "removed";
  DiffType["common"] = "common";
  DiffType["added"] = "added";
})(DiffType || (DiffType = {}));
const REMOVED = 1;
const COMMON = 2;
const ADDED = 3;
function createCommon(A, B, reverse) {
  const common = [];
  if (A.length === 0 || B.length === 0) return [];
  for(let i = 0; i < Math.min(A.length, B.length); i += 1){
    if (A[reverse ? A.length - i - 1 : i] === B[reverse ? B.length - i - 1 : i]) {
      common.push(A[reverse ? A.length - i - 1 : i]);
    } else {
      return common;
    }
  }
  return common;
}
/**
 * Renders the differences between the actual and expected values
 * @param A Actual value
 * @param B Expected value
 */ export function diff(A, B) {
  const prefixCommon = createCommon(A, B);
  const suffixCommon = createCommon(A.slice(prefixCommon.length), B.slice(prefixCommon.length), true).reverse();
  A = suffixCommon.length ? A.slice(prefixCommon.length, -suffixCommon.length) : A.slice(prefixCommon.length);
  B = suffixCommon.length ? B.slice(prefixCommon.length, -suffixCommon.length) : B.slice(prefixCommon.length);
  const swapped = B.length > A.length;
  [A, B] = swapped ? [
    B,
    A
  ] : [
    A,
    B
  ];
  const M = A.length;
  const N = B.length;
  if (!M && !N && !suffixCommon.length && !prefixCommon.length) return [];
  if (!N) {
    return [
      ...prefixCommon.map((c)=>({
          type: DiffType.common,
          value: c
        })),
      ...A.map((a)=>({
          type: swapped ? DiffType.added : DiffType.removed,
          value: a
        })),
      ...suffixCommon.map((c)=>({
          type: DiffType.common,
          value: c
        }))
    ];
  }
  const offset = N;
  const delta = M - N;
  const size = M + N + 1;
  const fp = Array.from({
    length: size
  }, ()=>({
      y: -1,
      id: -1
    }));
  /**
   * INFO:
   * This buffer is used to save memory and improve performance.
   * The first half is used to save route and last half is used to save diff
   * type.
   * This is because, when I kept new uint8array area to save type,performance
   * worsened.
   */ const routes = new Uint32Array((M * N + size + 1) * 2);
  const diffTypesPtrOffset = routes.length / 2;
  let ptr = 0;
  let p = -1;
  function backTrace(A, B, current, swapped) {
    const M = A.length;
    const N = B.length;
    const result = [];
    let a = M - 1;
    let b = N - 1;
    let j = routes[current.id];
    let type = routes[current.id + diffTypesPtrOffset];
    while(true){
      if (!j && !type) break;
      const prev = j;
      if (type === REMOVED) {
        result.unshift({
          type: swapped ? DiffType.removed : DiffType.added,
          value: B[b]
        });
        b -= 1;
      } else if (type === ADDED) {
        result.unshift({
          type: swapped ? DiffType.added : DiffType.removed,
          value: A[a]
        });
        a -= 1;
      } else {
        result.unshift({
          type: DiffType.common,
          value: A[a]
        });
        a -= 1;
        b -= 1;
      }
      j = routes[prev];
      type = routes[prev + diffTypesPtrOffset];
    }
    return result;
  }
  function createFP(slide, down, k, M) {
    if (slide && slide.y === -1 && down && down.y === -1) {
      return {
        y: 0,
        id: 0
      };
    }
    if (down && down.y === -1 || k === M || (slide && slide.y) > (down && down.y) + 1) {
      const prev = slide.id;
      ptr++;
      routes[ptr] = prev;
      routes[ptr + diffTypesPtrOffset] = ADDED;
      return {
        y: slide.y,
        id: ptr
      };
    } else {
      const prev = down.id;
      ptr++;
      routes[ptr] = prev;
      routes[ptr + diffTypesPtrOffset] = REMOVED;
      return {
        y: down.y + 1,
        id: ptr
      };
    }
  }
  function snake(k, slide, down, _offset, A, B) {
    const M = A.length;
    const N = B.length;
    if (k < -N || M < k) return {
      y: -1,
      id: -1
    };
    const fp = createFP(slide, down, k, M);
    while(fp.y + k < M && fp.y < N && A[fp.y + k] === B[fp.y]){
      const prev = fp.id;
      ptr++;
      fp.id = ptr;
      fp.y += 1;
      routes[ptr] = prev;
      routes[ptr + diffTypesPtrOffset] = COMMON;
    }
    return fp;
  }
  while(fp[delta + offset].y < N){
    p = p + 1;
    for(let k = -p; k < delta; ++k){
      fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
    }
    for(let k = delta + p; k > delta; --k){
      fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
    }
    fp[delta + offset] = snake(delta, fp[delta - 1 + offset], fp[delta + 1 + offset], offset, A, B);
  }
  return [
    ...prefixCommon.map((c)=>({
        type: DiffType.common,
        value: c
      })),
    ...backTrace(A, B, fp[delta + offset], swapped),
    ...suffixCommon.map((c)=>({
        type: DiffType.common,
        value: c
      }))
  ];
}
/**
 * Renders the differences between the actual and expected strings
 * Partially inspired from https://github.com/kpdecker/jsdiff
 * @param A Actual string
 * @param B Expected string
 */ export function diffstr(A, B) {
  function unescape(string) {
    // unescape invisible characters.
    // ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#escape_sequences
    return string.replaceAll("\b", "\\b").replaceAll("\f", "\\f").replaceAll("\t", "\\t").replaceAll("\v", "\\v").replaceAll(/\r\n|\r|\n/g, (str)=>str === "\r" ? "\\r" : str === "\n" ? "\\n\n" : "\\r\\n\r\n");
  }
  function tokenize(string, { wordDiff = false } = {}) {
    if (wordDiff) {
      // Split string on whitespace symbols
      const tokens = string.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
      // Extended Latin character set
      const words = /^[a-zA-Z\u{C0}-\u{FF}\u{D8}-\u{F6}\u{F8}-\u{2C6}\u{2C8}-\u{2D7}\u{2DE}-\u{2FF}\u{1E00}-\u{1EFF}]+$/u;
      // Join boundary splits that we do not consider to be boundaries and merge empty strings surrounded by word chars
      for(let i = 0; i < tokens.length - 1; i++){
        if (!tokens[i + 1] && tokens[i + 2] && words.test(tokens[i]) && words.test(tokens[i + 2])) {
          tokens[i] += tokens[i + 2];
          tokens.splice(i + 1, 2);
          i--;
        }
      }
      return tokens.filter((token)=>token);
    } else {
      // Split string on new lines symbols
      const tokens = [], lines = string.split(/(\n|\r\n)/);
      // Ignore final empty token when text ends with a newline
      if (!lines[lines.length - 1]) {
        lines.pop();
      }
      // Merge the content and line separators into single tokens
      for(let i = 0; i < lines.length; i++){
        if (i % 2) {
          tokens[tokens.length - 1] += lines[i];
        } else {
          tokens.push(lines[i]);
        }
      }
      return tokens;
    }
  }
  // Create details by filtering relevant word-diff for current line
  // and merge "space-diff" if surrounded by word-diff for cleaner displays
  function createDetails(line, tokens) {
    return tokens.filter(({ type })=>type === line.type || type === DiffType.common).map((result, i, t)=>{
      if (result.type === DiffType.common && t[i - 1] && t[i - 1]?.type === t[i + 1]?.type && /\s+/.test(result.value)) {
        return {
          ...result,
          type: t[i - 1].type
        };
      }
      return result;
    });
  }
  // Compute multi-line diff
  const diffResult = diff(tokenize(`${unescape(A)}\n`), tokenize(`${unescape(B)}\n`));
  const added = [], removed = [];
  for (const result of diffResult){
    if (result.type === DiffType.added) {
      added.push(result);
    }
    if (result.type === DiffType.removed) {
      removed.push(result);
    }
  }
  // Compute word-diff
  const aLines = added.length < removed.length ? added : removed;
  const bLines = aLines === removed ? added : removed;
  for (const a of aLines){
    let tokens = [], b;
    // Search another diff line with at least one common token
    while(bLines.length){
      b = bLines.shift();
      tokens = diff(tokenize(a.value, {
        wordDiff: true
      }), tokenize(b?.value ?? "", {
        wordDiff: true
      }));
      if (tokens.some(({ type, value })=>type === DiffType.common && value.trim().length)) {
        break;
      }
    }
    // Register word-diff details
    a.details = createDetails(a, tokens);
    if (b) {
      b.details = createDetails(b, tokens);
    }
  }
  return diffResult;
}
/**
 * Colors the output of assertion diffs
 * @param diffType Difference type, either added or removed
 */ function createColor(diffType, { background = false } = {}) {
  // TODO(@littledivy): Remove this when we can detect
  // true color terminals.
  // https://github.com/denoland/deno_std/issues/2575
  background = false;
  switch(diffType){
    case DiffType.added:
      return (s)=>background ? bgGreen(white(s)) : green(bold(s));
    case DiffType.removed:
      return (s)=>background ? bgRed(white(s)) : red(bold(s));
    default:
      return white;
  }
}
/**
 * Prefixes `+` or `-` in diff output
 * @param diffType Difference type, either added or removed
 */ function createSign(diffType) {
  switch(diffType){
    case DiffType.added:
      return "+   ";
    case DiffType.removed:
      return "-   ";
    default:
      return "    ";
  }
}
export function buildMessage(diffResult, { stringDiff = false } = {}) {
  const messages = [], diffMessages = [];
  messages.push("");
  messages.push("");
  messages.push(`    ${gray(bold("[Diff]"))} ${red(bold("Actual"))} / ${green(bold("Expected"))}`);
  messages.push("");
  messages.push("");
  diffResult.forEach((result)=>{
    const c = createColor(result.type);
    const line = result.details?.map((detail)=>detail.type !== DiffType.common ? createColor(detail.type, {
        background: true
      })(detail.value) : detail.value).join("") ?? result.value;
    diffMessages.push(c(`${createSign(result.type)}${line}`));
  });
  messages.push(...stringDiff ? [
    diffMessages.join("")
  ] : diffMessages);
  messages.push("");
  return messages;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vZGVuby5sYW5kL3N0ZEAwLjIwMy4wL2Fzc2VydC9fZGlmZi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxOC0yMDIzIHRoZSBEZW5vIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIE1JVCBsaWNlbnNlLlxuLy8gVGhpcyBtb2R1bGUgaXMgYnJvd3NlciBjb21wYXRpYmxlLlxuXG5pbXBvcnQge1xuICBiZ0dyZWVuLFxuICBiZ1JlZCxcbiAgYm9sZCxcbiAgZ3JheSxcbiAgZ3JlZW4sXG4gIHJlZCxcbiAgd2hpdGUsXG59IGZyb20gXCIuLi9mbXQvY29sb3JzLnRzXCI7XG5cbmludGVyZmFjZSBGYXJ0aGVzdFBvaW50IHtcbiAgeTogbnVtYmVyO1xuICBpZDogbnVtYmVyO1xufVxuXG5leHBvcnQgZW51bSBEaWZmVHlwZSB7XG4gIHJlbW92ZWQgPSBcInJlbW92ZWRcIixcbiAgY29tbW9uID0gXCJjb21tb25cIixcbiAgYWRkZWQgPSBcImFkZGVkXCIsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGlmZlJlc3VsdDxUPiB7XG4gIHR5cGU6IERpZmZUeXBlO1xuICB2YWx1ZTogVDtcbiAgZGV0YWlscz86IEFycmF5PERpZmZSZXN1bHQ8VD4+O1xufVxuXG5jb25zdCBSRU1PVkVEID0gMTtcbmNvbnN0IENPTU1PTiA9IDI7XG5jb25zdCBBRERFRCA9IDM7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbjxUPihBOiBUW10sIEI6IFRbXSwgcmV2ZXJzZT86IGJvb2xlYW4pOiBUW10ge1xuICBjb25zdCBjb21tb24gPSBbXTtcbiAgaWYgKEEubGVuZ3RoID09PSAwIHx8IEIubGVuZ3RoID09PSAwKSByZXR1cm4gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5taW4oQS5sZW5ndGgsIEIubGVuZ3RoKTsgaSArPSAxKSB7XG4gICAgaWYgKFxuICAgICAgQVtyZXZlcnNlID8gQS5sZW5ndGggLSBpIC0gMSA6IGldID09PSBCW3JldmVyc2UgPyBCLmxlbmd0aCAtIGkgLSAxIDogaV1cbiAgICApIHtcbiAgICAgIGNvbW1vbi5wdXNoKEFbcmV2ZXJzZSA/IEEubGVuZ3RoIC0gaSAtIDEgOiBpXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb21tb247XG4gICAgfVxuICB9XG4gIHJldHVybiBjb21tb247XG59XG5cbi8qKlxuICogUmVuZGVycyB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXNcbiAqIEBwYXJhbSBBIEFjdHVhbCB2YWx1ZVxuICogQHBhcmFtIEIgRXhwZWN0ZWQgdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmY8VD4oQTogVFtdLCBCOiBUW10pOiBBcnJheTxEaWZmUmVzdWx0PFQ+PiB7XG4gIGNvbnN0IHByZWZpeENvbW1vbiA9IGNyZWF0ZUNvbW1vbihBLCBCKTtcbiAgY29uc3Qgc3VmZml4Q29tbW9uID0gY3JlYXRlQ29tbW9uKFxuICAgIEEuc2xpY2UocHJlZml4Q29tbW9uLmxlbmd0aCksXG4gICAgQi5zbGljZShwcmVmaXhDb21tb24ubGVuZ3RoKSxcbiAgICB0cnVlLFxuICApLnJldmVyc2UoKTtcbiAgQSA9IHN1ZmZpeENvbW1vbi5sZW5ndGhcbiAgICA/IEEuc2xpY2UocHJlZml4Q29tbW9uLmxlbmd0aCwgLXN1ZmZpeENvbW1vbi5sZW5ndGgpXG4gICAgOiBBLnNsaWNlKHByZWZpeENvbW1vbi5sZW5ndGgpO1xuICBCID0gc3VmZml4Q29tbW9uLmxlbmd0aFxuICAgID8gQi5zbGljZShwcmVmaXhDb21tb24ubGVuZ3RoLCAtc3VmZml4Q29tbW9uLmxlbmd0aClcbiAgICA6IEIuc2xpY2UocHJlZml4Q29tbW9uLmxlbmd0aCk7XG4gIGNvbnN0IHN3YXBwZWQgPSBCLmxlbmd0aCA+IEEubGVuZ3RoO1xuICBbQSwgQl0gPSBzd2FwcGVkID8gW0IsIEFdIDogW0EsIEJdO1xuICBjb25zdCBNID0gQS5sZW5ndGg7XG4gIGNvbnN0IE4gPSBCLmxlbmd0aDtcbiAgaWYgKCFNICYmICFOICYmICFzdWZmaXhDb21tb24ubGVuZ3RoICYmICFwcmVmaXhDb21tb24ubGVuZ3RoKSByZXR1cm4gW107XG4gIGlmICghTikge1xuICAgIHJldHVybiBbXG4gICAgICAuLi5wcmVmaXhDb21tb24ubWFwKFxuICAgICAgICAoYyk6IERpZmZSZXN1bHQ8dHlwZW9mIGM+ID0+ICh7IHR5cGU6IERpZmZUeXBlLmNvbW1vbiwgdmFsdWU6IGMgfSksXG4gICAgICApLFxuICAgICAgLi4uQS5tYXAoXG4gICAgICAgIChhKTogRGlmZlJlc3VsdDx0eXBlb2YgYT4gPT4gKHtcbiAgICAgICAgICB0eXBlOiBzd2FwcGVkID8gRGlmZlR5cGUuYWRkZWQgOiBEaWZmVHlwZS5yZW1vdmVkLFxuICAgICAgICAgIHZhbHVlOiBhLFxuICAgICAgICB9KSxcbiAgICAgICksXG4gICAgICAuLi5zdWZmaXhDb21tb24ubWFwKFxuICAgICAgICAoYyk6IERpZmZSZXN1bHQ8dHlwZW9mIGM+ID0+ICh7IHR5cGU6IERpZmZUeXBlLmNvbW1vbiwgdmFsdWU6IGMgfSksXG4gICAgICApLFxuICAgIF07XG4gIH1cbiAgY29uc3Qgb2Zmc2V0ID0gTjtcbiAgY29uc3QgZGVsdGEgPSBNIC0gTjtcbiAgY29uc3Qgc2l6ZSA9IE0gKyBOICsgMTtcbiAgY29uc3QgZnA6IEZhcnRoZXN0UG9pbnRbXSA9IEFycmF5LmZyb20oXG4gICAgeyBsZW5ndGg6IHNpemUgfSxcbiAgICAoKSA9PiAoeyB5OiAtMSwgaWQ6IC0xIH0pLFxuICApO1xuICAvKipcbiAgICogSU5GTzpcbiAgICogVGhpcyBidWZmZXIgaXMgdXNlZCB0byBzYXZlIG1lbW9yeSBhbmQgaW1wcm92ZSBwZXJmb3JtYW5jZS5cbiAgICogVGhlIGZpcnN0IGhhbGYgaXMgdXNlZCB0byBzYXZlIHJvdXRlIGFuZCBsYXN0IGhhbGYgaXMgdXNlZCB0byBzYXZlIGRpZmZcbiAgICogdHlwZS5cbiAgICogVGhpcyBpcyBiZWNhdXNlLCB3aGVuIEkga2VwdCBuZXcgdWludDhhcnJheSBhcmVhIHRvIHNhdmUgdHlwZSxwZXJmb3JtYW5jZVxuICAgKiB3b3JzZW5lZC5cbiAgICovXG4gIGNvbnN0IHJvdXRlcyA9IG5ldyBVaW50MzJBcnJheSgoTSAqIE4gKyBzaXplICsgMSkgKiAyKTtcbiAgY29uc3QgZGlmZlR5cGVzUHRyT2Zmc2V0ID0gcm91dGVzLmxlbmd0aCAvIDI7XG4gIGxldCBwdHIgPSAwO1xuICBsZXQgcCA9IC0xO1xuXG4gIGZ1bmN0aW9uIGJhY2tUcmFjZTxUPihcbiAgICBBOiBUW10sXG4gICAgQjogVFtdLFxuICAgIGN1cnJlbnQ6IEZhcnRoZXN0UG9pbnQsXG4gICAgc3dhcHBlZDogYm9vbGVhbixcbiAgKTogQXJyYXk8e1xuICAgIHR5cGU6IERpZmZUeXBlO1xuICAgIHZhbHVlOiBUO1xuICB9PiB7XG4gICAgY29uc3QgTSA9IEEubGVuZ3RoO1xuICAgIGNvbnN0IE4gPSBCLmxlbmd0aDtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgYSA9IE0gLSAxO1xuICAgIGxldCBiID0gTiAtIDE7XG4gICAgbGV0IGogPSByb3V0ZXNbY3VycmVudC5pZF07XG4gICAgbGV0IHR5cGUgPSByb3V0ZXNbY3VycmVudC5pZCArIGRpZmZUeXBlc1B0ck9mZnNldF07XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICghaiAmJiAhdHlwZSkgYnJlYWs7XG4gICAgICBjb25zdCBwcmV2ID0gajtcbiAgICAgIGlmICh0eXBlID09PSBSRU1PVkVEKSB7XG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KHtcbiAgICAgICAgICB0eXBlOiBzd2FwcGVkID8gRGlmZlR5cGUucmVtb3ZlZCA6IERpZmZUeXBlLmFkZGVkLFxuICAgICAgICAgIHZhbHVlOiBCW2JdLFxuICAgICAgICB9KTtcbiAgICAgICAgYiAtPSAxO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBBRERFRCkge1xuICAgICAgICByZXN1bHQudW5zaGlmdCh7XG4gICAgICAgICAgdHlwZTogc3dhcHBlZCA/IERpZmZUeXBlLmFkZGVkIDogRGlmZlR5cGUucmVtb3ZlZCxcbiAgICAgICAgICB2YWx1ZTogQVthXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGEgLT0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KHsgdHlwZTogRGlmZlR5cGUuY29tbW9uLCB2YWx1ZTogQVthXSB9KTtcbiAgICAgICAgYSAtPSAxO1xuICAgICAgICBiIC09IDE7XG4gICAgICB9XG4gICAgICBqID0gcm91dGVzW3ByZXZdO1xuICAgICAgdHlwZSA9IHJvdXRlc1twcmV2ICsgZGlmZlR5cGVzUHRyT2Zmc2V0XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUZQKFxuICAgIHNsaWRlOiBGYXJ0aGVzdFBvaW50LFxuICAgIGRvd246IEZhcnRoZXN0UG9pbnQsXG4gICAgazogbnVtYmVyLFxuICAgIE06IG51bWJlcixcbiAgKTogRmFydGhlc3RQb2ludCB7XG4gICAgaWYgKHNsaWRlICYmIHNsaWRlLnkgPT09IC0xICYmIGRvd24gJiYgZG93bi55ID09PSAtMSkge1xuICAgICAgcmV0dXJuIHsgeTogMCwgaWQ6IDAgfTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgKGRvd24gJiYgZG93bi55ID09PSAtMSkgfHxcbiAgICAgIGsgPT09IE0gfHxcbiAgICAgIChzbGlkZSAmJiBzbGlkZS55KSA+IChkb3duICYmIGRvd24ueSkgKyAxXG4gICAgKSB7XG4gICAgICBjb25zdCBwcmV2ID0gc2xpZGUuaWQ7XG4gICAgICBwdHIrKztcbiAgICAgIHJvdXRlc1twdHJdID0gcHJldjtcbiAgICAgIHJvdXRlc1twdHIgKyBkaWZmVHlwZXNQdHJPZmZzZXRdID0gQURERUQ7XG4gICAgICByZXR1cm4geyB5OiBzbGlkZS55LCBpZDogcHRyIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByZXYgPSBkb3duLmlkO1xuICAgICAgcHRyKys7XG4gICAgICByb3V0ZXNbcHRyXSA9IHByZXY7XG4gICAgICByb3V0ZXNbcHRyICsgZGlmZlR5cGVzUHRyT2Zmc2V0XSA9IFJFTU9WRUQ7XG4gICAgICByZXR1cm4geyB5OiBkb3duLnkgKyAxLCBpZDogcHRyIH07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc25ha2U8VD4oXG4gICAgazogbnVtYmVyLFxuICAgIHNsaWRlOiBGYXJ0aGVzdFBvaW50LFxuICAgIGRvd246IEZhcnRoZXN0UG9pbnQsXG4gICAgX29mZnNldDogbnVtYmVyLFxuICAgIEE6IFRbXSxcbiAgICBCOiBUW10sXG4gICk6IEZhcnRoZXN0UG9pbnQge1xuICAgIGNvbnN0IE0gPSBBLmxlbmd0aDtcbiAgICBjb25zdCBOID0gQi5sZW5ndGg7XG4gICAgaWYgKGsgPCAtTiB8fCBNIDwgaykgcmV0dXJuIHsgeTogLTEsIGlkOiAtMSB9O1xuICAgIGNvbnN0IGZwID0gY3JlYXRlRlAoc2xpZGUsIGRvd24sIGssIE0pO1xuICAgIHdoaWxlIChmcC55ICsgayA8IE0gJiYgZnAueSA8IE4gJiYgQVtmcC55ICsga10gPT09IEJbZnAueV0pIHtcbiAgICAgIGNvbnN0IHByZXYgPSBmcC5pZDtcbiAgICAgIHB0cisrO1xuICAgICAgZnAuaWQgPSBwdHI7XG4gICAgICBmcC55ICs9IDE7XG4gICAgICByb3V0ZXNbcHRyXSA9IHByZXY7XG4gICAgICByb3V0ZXNbcHRyICsgZGlmZlR5cGVzUHRyT2Zmc2V0XSA9IENPTU1PTjtcbiAgICB9XG4gICAgcmV0dXJuIGZwO1xuICB9XG5cbiAgd2hpbGUgKGZwW2RlbHRhICsgb2Zmc2V0XS55IDwgTikge1xuICAgIHAgPSBwICsgMTtcbiAgICBmb3IgKGxldCBrID0gLXA7IGsgPCBkZWx0YTsgKytrKSB7XG4gICAgICBmcFtrICsgb2Zmc2V0XSA9IHNuYWtlKFxuICAgICAgICBrLFxuICAgICAgICBmcFtrIC0gMSArIG9mZnNldF0sXG4gICAgICAgIGZwW2sgKyAxICsgb2Zmc2V0XSxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBBLFxuICAgICAgICBCLFxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yIChsZXQgayA9IGRlbHRhICsgcDsgayA+IGRlbHRhOyAtLWspIHtcbiAgICAgIGZwW2sgKyBvZmZzZXRdID0gc25ha2UoXG4gICAgICAgIGssXG4gICAgICAgIGZwW2sgLSAxICsgb2Zmc2V0XSxcbiAgICAgICAgZnBbayArIDEgKyBvZmZzZXRdLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIEEsXG4gICAgICAgIEIsXG4gICAgICApO1xuICAgIH1cbiAgICBmcFtkZWx0YSArIG9mZnNldF0gPSBzbmFrZShcbiAgICAgIGRlbHRhLFxuICAgICAgZnBbZGVsdGEgLSAxICsgb2Zmc2V0XSxcbiAgICAgIGZwW2RlbHRhICsgMSArIG9mZnNldF0sXG4gICAgICBvZmZzZXQsXG4gICAgICBBLFxuICAgICAgQixcbiAgICApO1xuICB9XG4gIHJldHVybiBbXG4gICAgLi4ucHJlZml4Q29tbW9uLm1hcChcbiAgICAgIChjKTogRGlmZlJlc3VsdDx0eXBlb2YgYz4gPT4gKHsgdHlwZTogRGlmZlR5cGUuY29tbW9uLCB2YWx1ZTogYyB9KSxcbiAgICApLFxuICAgIC4uLmJhY2tUcmFjZShBLCBCLCBmcFtkZWx0YSArIG9mZnNldF0sIHN3YXBwZWQpLFxuICAgIC4uLnN1ZmZpeENvbW1vbi5tYXAoXG4gICAgICAoYyk6IERpZmZSZXN1bHQ8dHlwZW9mIGM+ID0+ICh7IHR5cGU6IERpZmZUeXBlLmNvbW1vbiwgdmFsdWU6IGMgfSksXG4gICAgKSxcbiAgXTtcbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHN0cmluZ3NcbiAqIFBhcnRpYWxseSBpbnNwaXJlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rcGRlY2tlci9qc2RpZmZcbiAqIEBwYXJhbSBBIEFjdHVhbCBzdHJpbmdcbiAqIEBwYXJhbSBCIEV4cGVjdGVkIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGlmZnN0cihBOiBzdHJpbmcsIEI6IHN0cmluZykge1xuICBmdW5jdGlvbiB1bmVzY2FwZShzdHJpbmc6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgLy8gdW5lc2NhcGUgaW52aXNpYmxlIGNoYXJhY3RlcnMuXG4gICAgLy8gcmVmOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcjZXNjYXBlX3NlcXVlbmNlc1xuICAgIHJldHVybiBzdHJpbmdcbiAgICAgIC5yZXBsYWNlQWxsKFwiXFxiXCIsIFwiXFxcXGJcIilcbiAgICAgIC5yZXBsYWNlQWxsKFwiXFxmXCIsIFwiXFxcXGZcIilcbiAgICAgIC5yZXBsYWNlQWxsKFwiXFx0XCIsIFwiXFxcXHRcIilcbiAgICAgIC5yZXBsYWNlQWxsKFwiXFx2XCIsIFwiXFxcXHZcIilcbiAgICAgIC5yZXBsYWNlQWxsKCAvLyBkb2VzIG5vdCByZW1vdmUgbGluZSBicmVha3NcbiAgICAgICAgL1xcclxcbnxcXHJ8XFxuL2csXG4gICAgICAgIChzdHIpID0+IHN0ciA9PT0gXCJcXHJcIiA/IFwiXFxcXHJcIiA6IHN0ciA9PT0gXCJcXG5cIiA/IFwiXFxcXG5cXG5cIiA6IFwiXFxcXHJcXFxcblxcclxcblwiLFxuICAgICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuaXplKHN0cmluZzogc3RyaW5nLCB7IHdvcmREaWZmID0gZmFsc2UgfSA9IHt9KTogc3RyaW5nW10ge1xuICAgIGlmICh3b3JkRGlmZikge1xuICAgICAgLy8gU3BsaXQgc3RyaW5nIG9uIHdoaXRlc3BhY2Ugc3ltYm9sc1xuICAgICAgY29uc3QgdG9rZW5zID0gc3RyaW5nLnNwbGl0KC8oW15cXFNcXHJcXG5dK3xbKClbXFxde30nXCJcXHJcXG5dfFxcYikvKTtcbiAgICAgIC8vIEV4dGVuZGVkIExhdGluIGNoYXJhY3RlciBzZXRcbiAgICAgIGNvbnN0IHdvcmRzID1cbiAgICAgICAgL15bYS16QS1aXFx1e0MwfS1cXHV7RkZ9XFx1e0Q4fS1cXHV7RjZ9XFx1e0Y4fS1cXHV7MkM2fVxcdXsyQzh9LVxcdXsyRDd9XFx1ezJERX0tXFx1ezJGRn1cXHV7MUUwMH0tXFx1ezFFRkZ9XSskL3U7XG5cbiAgICAgIC8vIEpvaW4gYm91bmRhcnkgc3BsaXRzIHRoYXQgd2UgZG8gbm90IGNvbnNpZGVyIHRvIGJlIGJvdW5kYXJpZXMgYW5kIG1lcmdlIGVtcHR5IHN0cmluZ3Mgc3Vycm91bmRlZCBieSB3b3JkIGNoYXJzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICF0b2tlbnNbaSArIDFdICYmIHRva2Vuc1tpICsgMl0gJiYgd29yZHMudGVzdCh0b2tlbnNbaV0pICYmXG4gICAgICAgICAgd29yZHMudGVzdCh0b2tlbnNbaSArIDJdKVxuICAgICAgICApIHtcbiAgICAgICAgICB0b2tlbnNbaV0gKz0gdG9rZW5zW2kgKyAyXTtcbiAgICAgICAgICB0b2tlbnMuc3BsaWNlKGkgKyAxLCAyKTtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0b2tlbnMuZmlsdGVyKCh0b2tlbikgPT4gdG9rZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTcGxpdCBzdHJpbmcgb24gbmV3IGxpbmVzIHN5bWJvbHNcbiAgICAgIGNvbnN0IHRva2VucyA9IFtdLCBsaW5lcyA9IHN0cmluZy5zcGxpdCgvKFxcbnxcXHJcXG4pLyk7XG5cbiAgICAgIC8vIElnbm9yZSBmaW5hbCBlbXB0eSB0b2tlbiB3aGVuIHRleHQgZW5kcyB3aXRoIGEgbmV3bGluZVxuICAgICAgaWYgKCFsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSkge1xuICAgICAgICBsaW5lcy5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWVyZ2UgdGhlIGNvbnRlbnQgYW5kIGxpbmUgc2VwYXJhdG9ycyBpbnRvIHNpbmdsZSB0b2tlbnNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgJSAyKSB7XG4gICAgICAgICAgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSArPSBsaW5lc1tpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaChsaW5lc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGRldGFpbHMgYnkgZmlsdGVyaW5nIHJlbGV2YW50IHdvcmQtZGlmZiBmb3IgY3VycmVudCBsaW5lXG4gIC8vIGFuZCBtZXJnZSBcInNwYWNlLWRpZmZcIiBpZiBzdXJyb3VuZGVkIGJ5IHdvcmQtZGlmZiBmb3IgY2xlYW5lciBkaXNwbGF5c1xuICBmdW5jdGlvbiBjcmVhdGVEZXRhaWxzKFxuICAgIGxpbmU6IERpZmZSZXN1bHQ8c3RyaW5nPixcbiAgICB0b2tlbnM6IEFycmF5PERpZmZSZXN1bHQ8c3RyaW5nPj4sXG4gICkge1xuICAgIHJldHVybiB0b2tlbnMuZmlsdGVyKCh7IHR5cGUgfSkgPT5cbiAgICAgIHR5cGUgPT09IGxpbmUudHlwZSB8fCB0eXBlID09PSBEaWZmVHlwZS5jb21tb25cbiAgICApLm1hcCgocmVzdWx0LCBpLCB0KSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIChyZXN1bHQudHlwZSA9PT0gRGlmZlR5cGUuY29tbW9uKSAmJiAodFtpIC0gMV0pICYmXG4gICAgICAgICh0W2kgLSAxXT8udHlwZSA9PT0gdFtpICsgMV0/LnR5cGUpICYmIC9cXHMrLy50ZXN0KHJlc3VsdC52YWx1ZSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICB0eXBlOiB0W2kgLSAxXS50eXBlLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIENvbXB1dGUgbXVsdGktbGluZSBkaWZmXG4gIGNvbnN0IGRpZmZSZXN1bHQgPSBkaWZmKFxuICAgIHRva2VuaXplKGAke3VuZXNjYXBlKEEpfVxcbmApLFxuICAgIHRva2VuaXplKGAke3VuZXNjYXBlKEIpfVxcbmApLFxuICApO1xuXG4gIGNvbnN0IGFkZGVkID0gW10sIHJlbW92ZWQgPSBbXTtcbiAgZm9yIChjb25zdCByZXN1bHQgb2YgZGlmZlJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQudHlwZSA9PT0gRGlmZlR5cGUuYWRkZWQpIHtcbiAgICAgIGFkZGVkLnB1c2gocmVzdWx0KTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC50eXBlID09PSBEaWZmVHlwZS5yZW1vdmVkKSB7XG4gICAgICByZW1vdmVkLnB1c2gocmVzdWx0KTtcbiAgICB9XG4gIH1cblxuICAvLyBDb21wdXRlIHdvcmQtZGlmZlxuICBjb25zdCBhTGluZXMgPSBhZGRlZC5sZW5ndGggPCByZW1vdmVkLmxlbmd0aCA/IGFkZGVkIDogcmVtb3ZlZDtcbiAgY29uc3QgYkxpbmVzID0gYUxpbmVzID09PSByZW1vdmVkID8gYWRkZWQgOiByZW1vdmVkO1xuICBmb3IgKGNvbnN0IGEgb2YgYUxpbmVzKSB7XG4gICAgbGV0IHRva2VucyA9IFtdIGFzIEFycmF5PERpZmZSZXN1bHQ8c3RyaW5nPj4sXG4gICAgICBiOiB1bmRlZmluZWQgfCBEaWZmUmVzdWx0PHN0cmluZz47XG4gICAgLy8gU2VhcmNoIGFub3RoZXIgZGlmZiBsaW5lIHdpdGggYXQgbGVhc3Qgb25lIGNvbW1vbiB0b2tlblxuICAgIHdoaWxlIChiTGluZXMubGVuZ3RoKSB7XG4gICAgICBiID0gYkxpbmVzLnNoaWZ0KCk7XG4gICAgICB0b2tlbnMgPSBkaWZmKFxuICAgICAgICB0b2tlbml6ZShhLnZhbHVlLCB7IHdvcmREaWZmOiB0cnVlIH0pLFxuICAgICAgICB0b2tlbml6ZShiPy52YWx1ZSA/PyBcIlwiLCB7IHdvcmREaWZmOiB0cnVlIH0pLFxuICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgdG9rZW5zLnNvbWUoKHsgdHlwZSwgdmFsdWUgfSkgPT5cbiAgICAgICAgICB0eXBlID09PSBEaWZmVHlwZS5jb21tb24gJiYgdmFsdWUudHJpbSgpLmxlbmd0aFxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlZ2lzdGVyIHdvcmQtZGlmZiBkZXRhaWxzXG4gICAgYS5kZXRhaWxzID0gY3JlYXRlRGV0YWlscyhhLCB0b2tlbnMpO1xuICAgIGlmIChiKSB7XG4gICAgICBiLmRldGFpbHMgPSBjcmVhdGVEZXRhaWxzKGIsIHRva2Vucyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpZmZSZXN1bHQ7XG59XG5cbi8qKlxuICogQ29sb3JzIHRoZSBvdXRwdXQgb2YgYXNzZXJ0aW9uIGRpZmZzXG4gKiBAcGFyYW0gZGlmZlR5cGUgRGlmZmVyZW5jZSB0eXBlLCBlaXRoZXIgYWRkZWQgb3IgcmVtb3ZlZFxuICovXG5mdW5jdGlvbiBjcmVhdGVDb2xvcihcbiAgZGlmZlR5cGU6IERpZmZUeXBlLFxuICB7IGJhY2tncm91bmQgPSBmYWxzZSB9ID0ge30sXG4pOiAoczogc3RyaW5nKSA9PiBzdHJpbmcge1xuICAvLyBUT0RPKEBsaXR0bGVkaXZ5KTogUmVtb3ZlIHRoaXMgd2hlbiB3ZSBjYW4gZGV0ZWN0XG4gIC8vIHRydWUgY29sb3IgdGVybWluYWxzLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZGVub2xhbmQvZGVub19zdGQvaXNzdWVzLzI1NzVcbiAgYmFja2dyb3VuZCA9IGZhbHNlO1xuICBzd2l0Y2ggKGRpZmZUeXBlKSB7XG4gICAgY2FzZSBEaWZmVHlwZS5hZGRlZDpcbiAgICAgIHJldHVybiAoczogc3RyaW5nKTogc3RyaW5nID0+XG4gICAgICAgIGJhY2tncm91bmQgPyBiZ0dyZWVuKHdoaXRlKHMpKSA6IGdyZWVuKGJvbGQocykpO1xuICAgIGNhc2UgRGlmZlR5cGUucmVtb3ZlZDpcbiAgICAgIHJldHVybiAoczogc3RyaW5nKTogc3RyaW5nID0+IGJhY2tncm91bmQgPyBiZ1JlZCh3aGl0ZShzKSkgOiByZWQoYm9sZChzKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB3aGl0ZTtcbiAgfVxufVxuXG4vKipcbiAqIFByZWZpeGVzIGArYCBvciBgLWAgaW4gZGlmZiBvdXRwdXRcbiAqIEBwYXJhbSBkaWZmVHlwZSBEaWZmZXJlbmNlIHR5cGUsIGVpdGhlciBhZGRlZCBvciByZW1vdmVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNpZ24oZGlmZlR5cGU6IERpZmZUeXBlKTogc3RyaW5nIHtcbiAgc3dpdGNoIChkaWZmVHlwZSkge1xuICAgIGNhc2UgRGlmZlR5cGUuYWRkZWQ6XG4gICAgICByZXR1cm4gXCIrICAgXCI7XG4gICAgY2FzZSBEaWZmVHlwZS5yZW1vdmVkOlxuICAgICAgcmV0dXJuIFwiLSAgIFwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCIgICAgXCI7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkTWVzc2FnZShcbiAgZGlmZlJlc3VsdDogUmVhZG9ubHlBcnJheTxEaWZmUmVzdWx0PHN0cmluZz4+LFxuICB7IHN0cmluZ0RpZmYgPSBmYWxzZSB9ID0ge30sXG4pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IG1lc3NhZ2VzOiBzdHJpbmdbXSA9IFtdLCBkaWZmTWVzc2FnZXM6IHN0cmluZ1tdID0gW107XG4gIG1lc3NhZ2VzLnB1c2goXCJcIik7XG4gIG1lc3NhZ2VzLnB1c2goXCJcIik7XG4gIG1lc3NhZ2VzLnB1c2goXG4gICAgYCAgICAke2dyYXkoYm9sZChcIltEaWZmXVwiKSl9ICR7cmVkKGJvbGQoXCJBY3R1YWxcIikpfSAvICR7XG4gICAgICBncmVlbihib2xkKFwiRXhwZWN0ZWRcIikpXG4gICAgfWAsXG4gICk7XG4gIG1lc3NhZ2VzLnB1c2goXCJcIik7XG4gIG1lc3NhZ2VzLnB1c2goXCJcIik7XG4gIGRpZmZSZXN1bHQuZm9yRWFjaCgocmVzdWx0OiBEaWZmUmVzdWx0PHN0cmluZz4pID0+IHtcbiAgICBjb25zdCBjID0gY3JlYXRlQ29sb3IocmVzdWx0LnR5cGUpO1xuICAgIGNvbnN0IGxpbmUgPSByZXN1bHQuZGV0YWlscz8ubWFwKChkZXRhaWwpID0+XG4gICAgICBkZXRhaWwudHlwZSAhPT0gRGlmZlR5cGUuY29tbW9uXG4gICAgICAgID8gY3JlYXRlQ29sb3IoZGV0YWlsLnR5cGUsIHsgYmFja2dyb3VuZDogdHJ1ZSB9KShkZXRhaWwudmFsdWUpXG4gICAgICAgIDogZGV0YWlsLnZhbHVlXG4gICAgKS5qb2luKFwiXCIpID8/IHJlc3VsdC52YWx1ZTtcbiAgICBkaWZmTWVzc2FnZXMucHVzaChjKGAke2NyZWF0ZVNpZ24ocmVzdWx0LnR5cGUpfSR7bGluZX1gKSk7XG4gIH0pO1xuICBtZXNzYWdlcy5wdXNoKC4uLihzdHJpbmdEaWZmID8gW2RpZmZNZXNzYWdlcy5qb2luKFwiXCIpXSA6IGRpZmZNZXNzYWdlcykpO1xuICBtZXNzYWdlcy5wdXNoKFwiXCIpO1xuXG4gIHJldHVybiBtZXNzYWdlcztcbn1cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwwRUFBMEU7QUFDMUUscUNBQXFDO0FBRXJDLFNBQ0UsT0FBTyxFQUNQLEtBQUssRUFDTCxJQUFJLEVBQ0osSUFBSSxFQUNKLEtBQUssRUFDTCxHQUFHLEVBQ0gsS0FBSyxRQUNBLG1CQUFtQjs7VUFPZDs7OztHQUFBLGFBQUE7QUFZWixNQUFNLFVBQVU7QUFDaEIsTUFBTSxTQUFTO0FBQ2YsTUFBTSxRQUFRO0FBRWQsU0FBUyxhQUFnQixDQUFNLEVBQUUsQ0FBTSxFQUFFLE9BQWlCO0VBQ3hELE1BQU0sU0FBUyxFQUFFO0VBQ2pCLElBQUksRUFBRSxNQUFNLEtBQUssS0FBSyxFQUFFLE1BQU0sS0FBSyxHQUFHLE9BQU8sRUFBRTtFQUMvQyxJQUFLLElBQUksSUFBSSxHQUFHLElBQUksS0FBSyxHQUFH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
// denoCacheMetadata=2957549855026295423,10575403259180303675