// /src/tests/compiler/dependency-graph.test.ts
import { assertEquals } from "https://deno.land/std@0.203.0/testing/asserts.ts";
import { DependencyGraph } from "../../src/compiler/dependency-graph.ts";
import * as pathModule from "https://deno.land/std@0.203.0/path/mod.ts";
/**
 * Mock ModuleInfo for testing.
 */ const mockModule = (path, code, dependencies)=>({
    path,
    code,
    dependencies,
    ast: {}
  });
// Cache resolved paths to avoid repeated path resolution
const resolvedPaths = new Map();
// Reusable mock parse module function factory with memoization
const createMockParseModule = (moduleMap)=>{
  const cache = new Map();
  return async (modulePath)=>{
    if (cache.has(modulePath)) {
      return cache.get(modulePath);
    }
    const modulePromise = (async ()=>{
      const resolvedPath = resolvedPaths.get(modulePath) || (()=>{
        const resolved = pathModule.resolve(modulePath);
        resolvedPaths.set(modulePath, resolved);
        return resolved;
      })();
      const module = moduleMap.get(resolvedPath);
      if (!module) {
        throw new Error(`Unknown module path: ${modulePath}`);
      }
      return module;
    })();
    cache.set(modulePath, modulePromise);
    return modulePromise;
  };
};
Deno.test("DependencyGraph - builds graph correctly", async ()=>{
  const graph = new DependencyGraph();
  const moduleMap = new Map();
  // Pre-resolve paths for better performance
  const entryPath = pathModule.resolve("entry.ts");
  const fooPath = pathModule.resolve("./foo.ts");
  const entryModule = mockModule(entryPath, "import { foo } from './foo.ts';", [
    fooPath
  ]);
  const fooModule = mockModule(fooPath, "export const foo = 'foo';", []);
  moduleMap.set(entryPath, entryModule);
  moduleMap.set(fooPath, fooModule);
  await graph.build(entryModule, {
    parseModule: createMockParseModule(moduleMap)
  });
  assertEquals(graph.getModule(entryPath)?.dependencies.length, 1, "Entry module should have one dependency");
  assertEquals(graph.getModule(fooPath)?.dependencies.length, 0, "Foo module should have no dependencies");
});
Deno.test("DependencyGraph - detects cycles", async ()=>{
  const graph = new DependencyGraph();
  const moduleMap = new Map();
  // Pre-resolve paths for better performance
  const aPath = pathModule.resolve("./a.ts");
  const bPath = pathModule.resolve("./b.ts");
  const moduleA = mockModule(aPath, "import { b } from './b.ts';", [
    bPath
  ]);
  const moduleB = mockModule(bPath, "import { a } from './a.ts';", [
    aPath
  ]);
  moduleMap.set(aPath, moduleA);
  moduleMap.set(bPath, moduleB);
  await graph.build(moduleA, {
    parseModule: createMockParseModule(moduleMap)
  });
  assertEquals(graph.hasCycle(), true, "DependencyGraph should detect a cycle between a.ts and b.ts");
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vVXNlcnMvcnlhbm9ib3lsZS9zdGVnYS90ZXN0cy9jb21waWxlci9kZXBlbmRlbmN5LWdyYXBoLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gL3NyYy90ZXN0cy9jb21waWxlci9kZXBlbmRlbmN5LWdyYXBoLnRlc3QudHNcbmltcG9ydCB7XG5cdGFzc2VydEVxdWFscyxcblx0YXNzZXJ0UmVqZWN0cyxcbn0gZnJvbSBcImh0dHBzOi8vZGVuby5sYW5kL3N0ZEAwLjIwMy4wL3Rlc3RpbmcvYXNzZXJ0cy50c1wiO1xuaW1wb3J0IHsgRGVwZW5kZW5jeUdyYXBoIH0gZnJvbSBcIi4uLy4uL3NyYy9jb21waWxlci9kZXBlbmRlbmN5LWdyYXBoLnRzXCI7XG5pbXBvcnQgdHlwZSB7IE1vZHVsZUluZm8gfSBmcm9tIFwiLi4vLi4vc3JjL2NvbXBpbGVyL3R5cGVzLnRzXCI7XG5pbXBvcnQgKiBhcyBwYXRoTW9kdWxlIGZyb20gXCJodHRwczovL2Rlbm8ubGFuZC9zdGRAMC4yMDMuMC9wYXRoL21vZC50c1wiO1xuXG4vKipcbiAqIE1vY2sgTW9kdWxlSW5mbyBmb3IgdGVzdGluZy5cbiAqL1xuY29uc3QgbW9ja01vZHVsZSA9IChcblx0cGF0aDogc3RyaW5nLFxuXHRjb2RlOiBzdHJpbmcsXG5cdGRlcGVuZGVuY2llczogc3RyaW5nW10sXG4pOiBNb2R1bGVJbmZvID0+ICh7XG5cdHBhdGgsXG5cdGNvZGUsXG5cdGRlcGVuZGVuY2llcyxcblx0YXN0OiB7fSBhcyB1bmtub3duLCAvLyBSZXBsYWNlIHdpdGggYWN0dWFsIEFTVCBpZiBuZWNlc3Nhcnlcbn0pO1xuXG4vLyBDYWNoZSByZXNvbHZlZCBwYXRocyB0byBhdm9pZCByZXBlYXRlZCBwYXRoIHJlc29sdXRpb25cbmNvbnN0IHJlc29sdmVkUGF0aHMgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpO1xuXG4vLyBSZXVzYWJsZSBtb2NrIHBhcnNlIG1vZHVsZSBmdW5jdGlvbiBmYWN0b3J5IHdpdGggbWVtb2l6YXRpb25cbmNvbnN0IGNyZWF0ZU1vY2tQYXJzZU1vZHVsZSA9IChtb2R1bGVNYXA6IE1hcDxzdHJpbmcsIE1vZHVsZUluZm8+KSA9PiB7XG5cdGNvbnN0IGNhY2hlID0gbmV3IE1hcDxzdHJpbmcsIFByb21pc2U8TW9kdWxlSW5mbz4+KCk7XG5cblx0cmV0dXJuIGFzeW5jIChtb2R1bGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPE1vZHVsZUluZm8+ID0+IHtcblx0XHRpZiAoY2FjaGUuaGFzKG1vZHVsZVBhdGgpKSB7XG5cdFx0XHRyZXR1cm4gY2FjaGUuZ2V0KG1vZHVsZVBhdGgpITtcblx0XHR9XG5cblx0XHRjb25zdCBtb2R1bGVQcm9taXNlID0gKGFzeW5jICgpID0+IHtcblx0XHRcdGNvbnN0IHJlc29sdmVkUGF0aCA9IHJlc29sdmVkUGF0aHMuZ2V0KG1vZHVsZVBhdGgpIHx8XG5cdFx0XHRcdCgoKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgcmVzb2x2ZWQgPSBwYXRoTW9kdWxlLnJlc29sdmUobW9kdWxlUGF0aCk7XG5cdFx0XHRcdFx0cmVzb2x2ZWRQYXRocy5zZXQobW9kdWxlUGF0aCwgcmVzb2x2ZWQpO1xuXHRcdFx0XHRcdHJldHVybiByZXNvbHZlZDtcblx0XHRcdFx0fSkoKTtcblxuXHRcdFx0Y29uc3QgbW9kdWxlID0gbW9kdWxlTWFwLmdldChyZXNvbHZlZFBhdGgpO1xuXHRcdFx0aWYgKCFtb2R1bGUpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG1vZHVsZSBwYXRoOiAke21vZHVsZVBhdGh9YCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbW9kdWxlO1xuXHRcdH0pKCk7XG5cblx0XHRjYWNoZS5zZXQobW9kdWxlUGF0aCwgbW9kdWxlUHJvbWlzZSk7XG5cdFx0cmV0dXJuIG1vZHVsZVByb21pc2U7XG5cdH07XG59O1xuXG5EZW5vLnRlc3QoXCJEZXBlbmRlbmN5R3JhcGggLSBidWlsZHMgZ3JhcGggY29ycmVjdGx5XCIsIGFzeW5jICgpID0+IHtcblx0Y29uc3QgZ3JhcGggPSBuZXcgRGVwZW5kZW5jeUdyYXBoKCk7XG5cdGNvbnN0IG1vZHVsZU1hcCA9IG5ldyBNYXA8c3RyaW5nLCBNb2R1bGVJbmZvPigpO1xuXG5cdC8vIFByZS1yZXNvbHZlIHBhdGhzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2Vcblx0Y29uc3QgZW50cnlQYXRoID0gcGF0aE1vZHVsZS5yZXNvbHZlKFwiZW50cnkudHNcIik7XG5cdGNvbnN0IGZvb1BhdGggPSBwYXRoTW9kdWxlLnJlc29sdmUoXCIuL2Zvby50c1wiKTtcblxuXHRjb25zdCBlbnRyeU1vZHVsZSA9IG1vY2tNb2R1bGUoXG5cdFx0ZW50cnlQYXRoLFxuXHRcdFwiaW1wb3J0IHsgZm9vIH0gZnJvbSAnLi9mb28udHMnO1wiLFxuXHRcdFtmb29QYXRoXSxcblx0KTtcblx0Y29uc3QgZm9vTW9kdWxlID0gbW9ja01vZHVsZShmb29QYXRoLCBcImV4cG9ydCBjb25zdCBmb28gPSAnZm9vJztcIiwgW10pO1xuXG5cdG1vZHVsZU1hcC5zZXQoZW50cnlQYXRoLCBlbnRyeU1vZHVsZSk7XG5cdG1vZHVsZU1hcC5zZXQoZm9vUGF0aCwgZm9vTW9kdWxlKTtcblxuXHRhd2FpdCBncmFwaC5idWlsZChlbnRyeU1vZHVsZSwge1xuXHRcdHBhcnNlTW9kdWxlOiBjcmVhdGVNb2NrUGFyc2VNb2R1bGUobW9kdWxlTWFwKSxcblx0fSk7XG5cblx0YXNzZXJ0RXF1YWxzKFxuXHRcdGdyYXBoLmdldE1vZHVsZShlbnRyeVBhdGgpPy5kZXBlbmRlbmNpZXMubGVuZ3RoLFxuXHRcdDEsXG5cdFx0XCJFbnRyeSBtb2R1bGUgc2hvdWxkIGhhdmUgb25lIGRlcGVuZGVuY3lcIixcblx0KTtcblx0YXNzZXJ0RXF1YWxzKFxuXHRcdGdyYXBoLmdldE1vZHVsZShmb29QYXRoKT8uZGVwZW5kZW5jaWVzLmxlbmd0aCxcblx0XHQwLFxuXHRcdFwiRm9vIG1vZHVsZSBzaG91bGQgaGF2ZSBubyBkZXBlbmRlbmNpZXNcIixcblx0KTtcbn0pO1xuXG5EZW5vLnRlc3QoXCJEZXBlbmRlbmN5R3JhcGggLSBkZXRlY3RzIGN5Y2xlc1wiLCBhc3luYyAoKSA9PiB7XG5cdGNvbnN0IGdyYXBoID0gbmV3IERlcGVuZGVuY3lHcmFwaCgpO1xuXHRjb25zdCBtb2R1bGVNYXAgPSBuZXcgTWFwPHN0cmluZywgTW9kdWxlSW5mbz4oKTtcblxuXHQvLyBQcmUtcmVzb2x2ZSBwYXRocyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG5cdGNvbnN0IGFQYXRoID0gcGF0aE1vZHVsZS5yZXNvbHZlKFwiLi9hLnRzXCIpO1xuXHRjb25zdCBiUGF0aCA9IHBhdGhNb2R1bGUucmVzb2x2ZShcIi4vYi50c1wiKTtcblxuXHRjb25zdCBtb2R1bGVBID0gbW9ja01vZHVsZShhUGF0aCwgXCJpbXBvcnQgeyBiIH0gZnJvbSAnLi9iLnRzJztcIiwgW2JQYXRoXSk7XG5cdGNvbnN0IG1vZHVsZUIgPSBtb2NrTW9kdWxlKGJQYXRoLCBcImltcG9ydCB7IGEgfSBmcm9tICcuL2EudHMnO1wiLCBbYVBhdGhdKTtcblxuXHRtb2R1bGVNYXAuc2V0KGFQYXRoLCBtb2R1bGVBKTtcblx0bW9kdWxlTWFwLnNldChiUGF0aCwgbW9kdWxlQik7XG5cblx0YXdhaXQgZ3JhcGguYnVpbGQobW9kdWxlQSwge1xuXHRcdHBhcnNlTW9kdWxlOiBjcmVhdGVNb2NrUGFyc2VNb2R1bGUobW9kdWxlTWFwKSxcblx0fSk7XG5cblx0YXNzZXJ0RXF1YWxzKFxuXHRcdGdyYXBoLmhhc0N5Y2xlKCksXG5cdFx0dHJ1ZSxcblx0XHRcIkRlcGVuZGVuY3lHcmFwaCBzaG91bGQgZGV0ZWN0IGEgY3ljbGUgYmV0d2VlbiBhLnRzIGFuZCBiLnRzXCIsXG5cdCk7XG59KTtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwrQ0FBK0M7QUFDL0MsU0FDQyxZQUFZLFFBRU4sbURBQW1EO0FBQzFELFNBQVMsZUFBZSxRQUFRLHlDQUF5QztBQUV6RSxZQUFZLGdCQUFnQiw0Q0FBNEM7QUFFeEU7O0NBRUMsR0FDRCxNQUFNLGFBQWEsQ0FDbEIsTUFDQSxNQUNBLGVBQ2dCLENBQUM7SUFDakI7SUFDQTtJQUNBO0lBQ0EsS0FBSyxDQUFDO0VBQ1AsQ0FBQztBQUVELHlEQUF5RDtBQUN6RCxNQUFNLGdCQUFnQixJQUFJO0FBRTFCLCtEQUErRDtBQUMvRCxNQUFNLHdCQUF3QixDQUFDO0VBQzlCLE1BQU0sUUFBUSxJQUFJO0VBRWxCLE9BQU8sT0FBTztJQUNiLElBQUksTUFBTSxHQUFHLENBQUMsYUFBYTtNQUMxQixPQUFPLE1BQU0sR0FBRyxDQUFDO0lBQ2xCO0lBRUEsTUFBTSxnQkFBZ0IsQ0FBQztNQUN0QixNQUFNLGVBQWUsY0FBYyxHQUFHLENBQUMsZUFDdEMsQ0FBQztRQUNBLE1BQU0sV0FBVyxXQUFXLE9BQU8sQ0FBQztRQUNwQyxjQUFjLEdBQUcsQ0FBQyxZQUFZO1FBQzlCLE9BQU87TUFDUixDQUFDO01BRUYsTUFBTSxTQUFTLFVBQVUsR0FBRyxDQUFDO01BQzdCLElBQUksQ0FBQyxRQUFRO1FBQ1osTUFBTSxJQUFJLE1BQU0sQ0FBQyxxQkFBcUIsRUFBRSxXQUFXLENBQUM7TUFDckQ7TUFDQSxPQUFPO0lBQ1IsQ0FBQztJQUVELE1BQU0sR0FBRyxDQUFDLFlBQVk7SUFDdEIsT0FBTztFQUNSO0FBQ0Q7QUFFQSxLQUFLLElBQUksQ0FBQyw0Q0FBNEM7RUFDckQsTUFBTSxRQUFRLElBQUk7RUFDbEIsTUFBTSxZQUFZLElBQUk7RUFFdEIsMkNBQTJDO0VBQzNDLE1BQU0sWUFBWSxXQUFXLE9BQU8sQ0FBQztFQUNyQyxNQUFNLFVBQVUsV0FBVyxPQUFPLENBQUM7RUFFbkMsTUFBTSxjQUFjLFdBQ25CLFdBQ0EsbUNBQ0E7SUFBQztHQUFRO0VBRVYsTUFBTSxZQUFZLFdBQVcsU0FBUyw2QkFBNkIsRUFBRTtFQUVyRSxVQUFVLEdBQUcsQ0FBQyxXQUFXO0VBQ3pCLFVBQVUsR0FBRyxDQUFDLFNBQVM7RUFFdkIsTUFBTSxNQUFNLEtBQUssQ0FBQyxhQUFhO0lBQzlCLGFBQWEsc0JBQXNCO0VBQ3BDO0VBRUEsYUFDQyxNQUFNLFNBQVMsQ0FBQyxZQUFZLGFBQWEsUUFDekMsR0FDQTtFQUVELGFBQ0MsTUFBTSxTQUFTLENBQUMsVUFBVSxhQUFhLFFBQ3ZDLEdBQ0E7QUFFRjtBQUVBLEtBQUssSUFBSSxDQUFDLG9DQUFvQztFQUM3QyxNQUFNLFFBQVEsSUFBSTtFQUNsQixNQUFNLFlBQVksSUFBSTtFQUV0QiwyQ0FBMkM7RUFDM0MsTUFBTSxRQUFRLFdBQVcsT0FBTyxDQUFDO0VBQ2pDLE1BQU0sUUFBUSxXQUFXLE9BQU8sQ0FBQztFQUVqQyxNQUFNLFVBQVUsV0FBVyxPQUFPLCtCQUErQjtJQUFDO0dBQU07RUFDeEUsTUFBTSxVQUFVLFdBQVcsT0FBTywrQkFBK0I7SUFBQztHQUFNO0VBRXhFLFVBQVUsR0FBRyxDQUFDLE9BQU87RUFDckIsVUFBVSxHQUFHLENBQUMsT0FBTztFQUVyQixNQUFNLE1BQU0sS0FBSyxDQUFDLFNBQVM7SUFDMUIsYUFBYSxzQkFBc0I7RUFDcEM7RUFFQSxhQUNDLE1BQU0sUUFBUSxJQUNkLE1BQ0E7QUFFRiJ9
// denoCacheMetadata=14014933638194922759,7449734126533450822