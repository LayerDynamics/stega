import type { KeyCode } from "../keycode/key_code.ts";
import {
  GenericPrompt,
  GenericPromptKeys,
  GenericPromptOptions,
  GenericPromptSettings,
} from "./_generic_prompt.ts";
import { brightBlue, dim, stripColor, underline } from "./deps.ts";

/** Generic input prompt options. */
export interface GenericInputPromptOptions<TValue, TRawValue>
  extends GenericPromptOptions<TValue, TRawValue> {
  /** Keymap to assign key names to prompt actions. */
  keys?: GenericInputKeys;
}

/** Generic input prompt settings. */
export interface GenericInputPromptSettings<TValue, TRawValue>
  extends GenericPromptSettings<TValue, TRawValue> {
  keys?: GenericInputKeys;
}

/** Input keys options. */
export interface GenericInputKeys extends GenericPromptKeys {
  /** Cursor left keymap. Default is `["left"]`. */
  moveCursorLeft?: string[];
  /** Cursor right keymap. Default is `["right"]`. */
  moveCursorRight?: string[];
  /** Delete cursor left keymap. Default is `["backspace"]`. */
  deleteCharLeft?: string[];
  /** Delete cursor right keymap. Default is `["delete"]`. */
  deleteCharRight?: string[];
}

/** Generic input prompt representation. */
export abstract class GenericInput<
  TValue,
  TRawValue,
> extends GenericPrompt<TValue, TRawValue> {
  protected abstract readonly settings: GenericInputPromptSettings<
    TValue,
    TRawValue
  >;
  protected inputValue = "";
  protected inputIndex = 0;

  public getDefaultSettings(
    options: GenericInputPromptOptions<TValue, TRawValue>,
  ): GenericInputPromptSettings<TValue, TRawValue> {
    const settings = super.getDefaultSettings(options);
    return {
      ...settings,
      keys: {
        moveCursorLeft: ["left"],
        moveCursorRight: ["right"],
        deleteCharLeft: ["backspace"],
        deleteCharRight: ["delete"],
        ...(settings.keys ?? {}),
      },
    };
  }

  protected getCurrentInputValue(): string {
    return this.inputValue;
  }

  protected message(): string {
    const message: string = super.message() + " " + this.settings.pointer + " ";
    this.cursor.x = stripColor(message).length + this.inputIndex + 1;
    return message + this.input();
  }

  protected input(): string {
    return underline(this.inputValue);
  }

  protected highlight(
    value: string | number,
    color1: (val: string) => string = dim,
    color2: (val: string) => string = brightBlue,
  ): string {
    value = value.toString();
    const inputLowerCase = this.getCurrentInputValue().toLowerCase();
    const valueLowerCase = value.toLowerCase();
    const index = valueLowerCase.indexOf(inputLowerCase);
    const matched: string = value.slice(index, index + inputLowerCase.length);
    return index >= 0
      ? color1(value.slice(0, index)) + color2(matched) +
        color1(value.slice(index + inputLowerCase.length))
      : value;
  }

  /**
   * Handle user input event.
   * @param event Key event.
   */
  protected async handleEvent(event: KeyCode): Promise<void> {
    switch (true) {
      case this.isKey(this.settings.keys, "moveCursorLeft", event):
        this.moveCursorLeft();
        break;
      case this.isKey(this.settings.keys, "moveCursorRight", event):
        this.moveCursorRight();
        break;
      case this.isKey(this.settings.keys, "deleteCharRight", event):
        this.deleteCharRight();
        break;
      case this.isKey(this.settings.keys, "deleteCharLeft", event):
        this.deleteChar();
        break;
      case event.char && !event.meta && !event.ctrl:
        this.addChar(event.char!);
        break;
      default:
        await super.handleEvent(event);
    }
  }

  /** Add character to current input. */
  protected addChar(char: string): void {
    this.inputValue = this.inputValue.slice(0, this.inputIndex) + char +
      this.inputValue.slice(this.inputIndex);
    this.inputIndex++;
  }

  /** Move prompt cursor left. */
  protected moveCursorLeft(): void {
    if (this.inputIndex > 0) {
      this.inputIndex--;
    }
  }

  /** Move prompt cursor right. */
  protected moveCursorRight(): void {
    if (this.inputIndex < this.inputValue.length) {
      this.inputIndex++;
    }
  }

  /** Delete char left. */
  protected deleteChar(): void {
    if (this.inputIndex > 0) {
      this.inputIndex--;
      this.deleteCharRight();
    }
  }

  /** Delete char right. */
  protected deleteCharRight(): void {
    if (this.inputIndex < this.inputValue.length) {
      this.inputValue = this.inputValue.slice(0, this.inputIndex) +
        this.inputValue.slice(this.inputIndex + 1);
    }
  }
}

// denoCacheMetadata={"headers":{"via":"http/2 edgeproxy-h","vary":"Accept-Encoding, Origin","x-amz-replication-status":"COMPLETED","x-frame-options":"DENY","x-amz-cf-id":"dzyfpPEj0bz6JIRI5NpFkafHlFk8G5V4xfYfWhhlQjCGXDpJK8likw==","x-amz-cf-pop":"IAD12-P5","cross-origin-resource-policy":"same-origin","referrer-policy":"strict-origin-when-cross-origin","x-cache":"Hit from cloudfront","x-amz-version-id":"JA3XUN_YDuafZtE76SnxsMN15mvPfipA","content-length":"4554","x-content-type-options":"nosniff","server-timing":"fetchSource;dur=24","last-modified":"Sun, 30 Jul 2023 10:00:26 GMT","cross-origin-embedder-policy":"same-origin","strict-transport-security":"max-age=63072000; includeSubDomains; preload","x-amz-server-side-encryption":"AES256","cache-control":"public, max-age=31536000, immutable","accept-ranges":"bytes","access-control-allow-origin":"*","content-security-policy":"default-src 'none'; style-src 'unsafe-inline'; sandbox","etag":"\"1a804a45d5b4c55840c983b096c62126\"","age":"111820","cross-origin-opener-policy":"same-origin","server":"deno/gcp-us-east4","date":"Mon, 13 Jan 2025 04:05:25 GMT","content-type":"application/typescript; charset=utf-8"},"url":"https://deno.land/x/cliffy@v1.0.0-rc.3/prompt/_generic_input.ts","time":1736852944}