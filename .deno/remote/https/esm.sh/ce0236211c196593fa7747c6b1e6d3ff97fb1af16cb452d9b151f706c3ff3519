import type { SourceMapSegment } from './sourcemap-segment.d.ts';
import type { SourceMapV3, DecodedSourceMap, EncodedSourceMap, InvalidOriginalMapping, OriginalMapping, InvalidGeneratedMapping, GeneratedMapping, SourceMapInput, Needle, SourceNeedle, SourceMap, EachMapping } from './types.d.ts';
export type { SourceMapSegment } from './sourcemap-segment.d.ts';
export type { SourceMap, DecodedSourceMap, EncodedSourceMap, Section, SectionedSourceMap, SourceMapV3, Bias, EachMapping, GeneratedMapping, InvalidGeneratedMapping, InvalidOriginalMapping, Needle, OriginalMapping, OriginalMapping as Mapping, SectionedSourceMapInput, SourceMapInput, SourceNeedle, XInput, EncodedSourceMapXInput, DecodedSourceMapXInput, SectionedSourceMapXInput, SectionXInput, } from './types.d.ts';
export declare const LEAST_UPPER_BOUND = -1;
export declare const GREATEST_LOWER_BOUND = 1;
export { AnyMap } from './any-map.d.ts';
export declare class TraceMap implements SourceMap {
    version: SourceMapV3['version'];
    file: SourceMapV3['file'];
    names: SourceMapV3['names'];
    sourceRoot: SourceMapV3['sourceRoot'];
    sources: SourceMapV3['sources'];
    sourcesContent: SourceMapV3['sourcesContent'];
    ignoreList: SourceMapV3['ignoreList'];
    resolvedSources: string[];
    private _encoded;
    private _decoded;
    private _decodedMemo;
    private _bySources;
    private _bySourceMemos;
    constructor(map: SourceMapInput, mapUrl?: string | null);
}
/**
 * Returns the encoded (VLQ string) form of the SourceMap's mappings field.
 */
export declare function encodedMappings(map: TraceMap): EncodedSourceMap['mappings'];
/**
 * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.
 */
export declare function decodedMappings(map: TraceMap): Readonly<DecodedSourceMap['mappings']>;
/**
 * A low-level API to find the segment associated with a generated line/column (think, from a
 * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.
 */
export declare function traceSegment(map: TraceMap, line: number, column: number): Readonly<SourceMapSegment> | null;
/**
 * A higher-level API to find the source/line/column associated with a generated line/column
 * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in
 * `source-map` library.
 */
export declare function originalPositionFor(map: TraceMap, needle: Needle): OriginalMapping | InvalidOriginalMapping;
/**
 * Finds the generated line/column position of the provided source/line/column source position.
 */
export declare function generatedPositionFor(map: TraceMap, needle: SourceNeedle): GeneratedMapping | InvalidGeneratedMapping;
/**
 * Finds all generated line/column positions of the provided source/line/column source position.
 */
export declare function allGeneratedPositionsFor(map: TraceMap, needle: SourceNeedle): GeneratedMapping[];
/**
 * Iterates each mapping in generated position order.
 */
export declare function eachMapping(map: TraceMap, cb: (mapping: EachMapping) => void): void;
/**
 * Retrieves the source content for a particular source, if its found. Returns null if not.
 */
export declare function sourceContentFor(map: TraceMap, source: string): string | null;
/**
 * Determines if the source is marked to ignore by the source map.
 */
export declare function isIgnored(map: TraceMap, source: string): boolean;
/**
 * A helper that skips sorting of the input map's mappings array, which can be expensive for larger
 * maps.
 */
export declare function presortedDecodedMap(map: DecodedSourceMap, mapUrl?: string): TraceMap;
/**
 * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects
 * a sourcemap, or to JSON.stringify.
 */
export declare function decodedMap(map: TraceMap): Omit<DecodedSourceMap, 'mappings'> & {
    mappings: readonly SourceMapSegment[][];
};
/**
 * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects
 * a sourcemap, or to JSON.stringify.
 */
export declare function encodedMap(map: TraceMap): EncodedSourceMap;

// denoCacheMetadata={"headers":{"alt-svc":"h3=\":443\"; ma=86400","content-length":"4117","cf-ray":"901d2bf94a890cba-EWR","accept-ranges":"bytes","server":"cloudflare","vary":"Origin, Accept-Encoding","cf-cache-status":"HIT","access-control-allow-origin":"*","x-content-source":"esm-worker","date":"Tue, 14 Jan 2025 11:09:04 GMT","access-control-allow-methods":"*","content-type":"application/typescript; charset=utf-8","age":"302","cache-control":"public, max-age=31536000, immutable","last-modified":"Tue, 14 Jan 2025 11:04:02 GMT","server-timing":"cfL4;desc=\"?proto=TCP&rtt=8353&min_rtt=6150&rtt_var=725&sent=244&recv=44&lost=0&retrans=0&sent_bytes=250618&recv_bytes=1498&delivery_rate=20614392&cwnd=399&unsent_bytes=0&cid=e236419c9303ab2c&ts=626&x=0\""},"url":"https://esm.sh/v135/@jridgewell/trace-mapping@0.3.25/dist/types/trace-mapping.d.ts","time":1736852944}