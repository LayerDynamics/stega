import type { SourceMapSegment } from './sourcemap-segment.d.ts';
import type { GREATEST_LOWER_BOUND, LEAST_UPPER_BOUND, TraceMap } from './trace-mapping.d.ts';
export interface SourceMapV3 {
    file?: string | null;
    names: string[];
    sourceRoot?: string;
    sources: (string | null)[];
    sourcesContent?: (string | null)[];
    version: 3;
    ignoreList?: number[];
}
export interface EncodedSourceMap extends SourceMapV3 {
    mappings: string;
}
export interface DecodedSourceMap extends SourceMapV3 {
    mappings: SourceMapSegment[][];
}
export interface Section {
    offset: {
        line: number;
        column: number;
    };
    map: EncodedSourceMap | DecodedSourceMap | SectionedSourceMap;
}
export interface SectionedSourceMap {
    file?: string | null;
    sections: Section[];
    version: 3;
}
export type OriginalMapping = {
    source: string | null;
    line: number;
    column: number;
    name: string | null;
};
export type InvalidOriginalMapping = {
    source: null;
    line: null;
    column: null;
    name: null;
};
export type GeneratedMapping = {
    line: number;
    column: number;
};
export type InvalidGeneratedMapping = {
    line: null;
    column: null;
};
export type Bias = typeof GREATEST_LOWER_BOUND | typeof LEAST_UPPER_BOUND;
export type XInput = {
    x_google_ignoreList?: SourceMapV3['ignoreList'];
};
export type EncodedSourceMapXInput = EncodedSourceMap & XInput;
export type DecodedSourceMapXInput = DecodedSourceMap & XInput;
export type SectionedSourceMapXInput = Omit<SectionedSourceMap, 'sections'> & {
    sections: SectionXInput[];
};
export type SectionXInput = Omit<Section, 'map'> & {
    map: SectionedSourceMapInput;
};
export type SourceMapInput = string | EncodedSourceMapXInput | DecodedSourceMapXInput | TraceMap;
export type SectionedSourceMapInput = SourceMapInput | SectionedSourceMapXInput;
export type Needle = {
    line: number;
    column: number;
    bias?: Bias;
};
export type SourceNeedle = {
    source: string;
    line: number;
    column: number;
    bias?: Bias;
};
export type EachMapping = {
    generatedLine: number;
    generatedColumn: number;
    source: null;
    originalLine: null;
    originalColumn: null;
    name: null;
} | {
    generatedLine: number;
    generatedColumn: number;
    source: string | null;
    originalLine: number;
    originalColumn: number;
    name: string | null;
};
export declare abstract class SourceMap {
    version: SourceMapV3['version'];
    file: SourceMapV3['file'];
    names: SourceMapV3['names'];
    sourceRoot: SourceMapV3['sourceRoot'];
    sources: SourceMapV3['sources'];
    sourcesContent: SourceMapV3['sourcesContent'];
    resolvedSources: SourceMapV3['sources'];
    ignoreList: SourceMapV3['ignoreList'];
}

// denoCacheMetadata={"headers":{"server":"cloudflare","x-content-source":"esm-worker","accept-ranges":"bytes","cf-cache-status":"HIT","date":"Tue, 14 Jan 2025 11:09:05 GMT","cache-control":"public, max-age=31536000, immutable","server-timing":"cfL4;desc=\"?proto=TCP&rtt=7869&min_rtt=6150&rtt_var=720&sent=272&recv=52&lost=0&retrans=0&sent_bytes=265483&recv_bytes=1776&delivery_rate=20614392&cwnd=399&unsent_bytes=0&cid=e236419c9303ab2c&ts=809&x=0\"","content-length":"2767","age":"303","cf-ray":"901d2bfa6b580cba-EWR","alt-svc":"h3=\":443\"; ma=86400","access-control-allow-methods":"*","access-control-allow-origin":"*","content-type":"application/typescript; charset=utf-8","last-modified":"Tue, 14 Jan 2025 11:04:02 GMT","vary":"Origin, Accept-Encoding"},"url":"https://esm.sh/v135/@jridgewell/trace-mapping@0.3.25/dist/types/types.d.ts","time":1736852945}